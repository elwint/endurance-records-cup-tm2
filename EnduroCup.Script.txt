/*
Endurance Gamemode for TrackMania 2
Copyright (C) 2013 TGYoshi/Tiggs
Modified to EnduroCup by Virtex (fsxelw) (05-2017)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#RequireContext CTmMode
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/TrackMania/TM3.Script.txt" as TM
#Include "Libs/Nadeo/TrackMania/WarmUp.Script.txt" as WarmUp
#Include "Libs/Nadeo/ModeInfo.Script.txt" as ModeInfo
#Const	Version				"V5.0-cup V1.4b-alpha"

//// GENERIC SETTINGS ////
#Const PlayersReq 				2		// PLAYERS REQUIRED BEFORE THE GAME STARTS (Generally >= 2)
#Const WarmupTime 				10000	// WARMING UP TIME IN MS (1000 = 1 second)
#Const TimeMargeP1				30000   // START TIME MARGE
#Const TimeMargeP2				0.95    // DEFAULT MULTIPLICATION PER CP (Generally <= 1.0)
#Const RoundEndWait				5000	// WAITING TIME AT ROUNDEND in MS (1000 = 1 second)
#Const MatchEndWait				20000	// WAITING TIME AT MATCHEND in MS (1000 = 1 second)
#Const SkipIntro				1		// SKIP INTRO? (0 = no, 1 = yes)

//// DEBUG SETTINGS ////
#Const EndOnVictory				1		// Set to 0 to prevent the match from ending (debug). (default 1)
#Const SimulateFakeplayerCP		0		// Default time in ms to reach next CP for random fakeplayer, set to 0 to disable fakeplayer simulation (debug). (default 0)

//// MODE CONSTANTS ////
#Const Description				_("""$fff$lhttps://www.facebook.com/TeamProfessionalsTM/$l""")
#Const StatusMessage			_("TYPE: Free for all\nOBJECTIVE: Don't get eliminated by the timer.")
#Const C_UITickPeriod			300
#Const DfWarmingUp				"$fb2Warming up"


Text GetTime(Integer StartTime) {
	declare Text r = TextLib::TimeToText(Now-StartTime);
	declare Text b = TextLib::ToText(Now-StartTime);
	r ^= "."^TextLib::SubString(b, TextLib::Length(b)-3, 3);
	return r;
}
Text GetTime2(Integer RealTime) {
	declare Text r = TextLib::TimeToText(RealTime);
	declare Text b = TextLib::ToText(RealTime+10000);
	r ^= "."^TextLib::SubString(b, TextLib::Length(b)-3, 3);
	return r;
}
Text GetLegitBoolText(Boolean what) {
	if (what)
		return "true";
	return "false";
}

declare Text EndLatestKO;
declare Text EndWinner;

Text MLGet_ScoreTable(Boolean EndRound) {
	declare ML = """
	<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
	<manialink version="3" name="ScoresTable">
		<!-- Modified version of original TA scoretable, exported from \Modules\Nadeo\TrackMania\TimeAttack\ScoresTable.Module.Gbx -->
		<stylesheet>
			<style class="text-default" textfont="Oswald" textcolor="fff" textemboss="1"/>
			<style class="text-number" textfont="OswaldMono" textcolor="fff" textemboss="1"/>
		</stylesheet>
		<frame pos="0 70.5" z-index="0" scale="1">
			<framemodel id="framemodelcolumnheader">
				<quad size="68.1 0.8" valign="bottom" colorize="1ec8c2" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderSmall.dds" />
				<quad pos="68 0" size="26.8 0.8" valign="bottom" colorize="1ec8c2" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderBig.dds" />
			</framemodel>
			<framemodel id="framemodelscorecard">
				<frame z-index="-100" >
					<quad pos="16 -6.23" size="10 0.8" rot="90" halign="center" valign="center" opacity="0.1" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderSmall.dds" />
					<quad pos="3.70 -6.23" z-index="-1" size="95 12" valign="center" opacity="0.5" colorize="0b081b" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/Colorize.dds" />
					<quad pos="3 -6.23" z-index="-2" size="96.5 13" valign="center" opacity="0.8" id="scorecard_quadbackgroundblink" style="Icons128x128_Blink" substyle="ShareBlink" hidden="1"/>
					<quad pos="3.70 -6.23" z-index="-3" size="95 12" valign="center" style="Bgs1" substyle="BgDialogBlur" opacity="0.35" />
				</frame>
				<label pos="9.93 -6.23" size="12.45 12.45" scale="0.80" halign="center" valign="center2" textsize="7" text="0" class="text-number" id="scorecard_localrank"/>
				<frame pos="16.15 -8.9">
					<quad pos="1.97 -1.68" size="3.36 3.36" scale="0.9" halign="left" valign="center" style="Icons64x64_1" substyle="LvlGreen" id="scorecard_quadstatus"/>
					<label pos="5.71 -1.68" size="41.27 3.36" valign="center2" textsize="1" textcolor="aeacb0" textprefix="$t> " text="WORLD: NOT RANKED" class="text-default" id="scorecard_labelmultirank"/>
					<frame id="framelpgain" hidden="1">
						<quad pos="52.32 -1.68" size="3.36 3.36" scale="1.5" valign="center" style="Icons128x128_1" substyle="LadderPoints"/>
						<label pos="51.70 -1.68" size="33.02 3.36" halign="right" valign="center2" textcolor="bb8" textsize="1.5" text="+0.00" class="text-number" id="scorecard_labellpgain"/>
					</frame>
					<frame id="framepointsgain" hidden="1">
						<label pos="75.57 -0.5" size="33.02 3.36" halign="left" valign="center2" textcolor="0F0" textsize="1.5" text="+250" class="text-number" id="scorecard_labelpointsgain"/>
					</frame>
				</frame>
				<frame z-index="1">
					<label pos="97.40 -4.67" size="16.92 12.45" halign="right" valign="center2" text="CP: 0" textsize="2.00" class="text-number" id="columns_labeltmpoints" z-index="-1"/>
					<quad pos="77.23 -2.98" size="3.90 3.90" halign="center" valign="center" scale="1.3" style="UIConstructionSimple_Buttons" substyle="Camera" scriptevents="1" id="columns_quadspec"/>
					<quad pos="77.23 -7.11" size="3.90 3.90" halign="center" valign="center" scale="1.3" style="UIConstructionSimple_Buttons" substyle="Author" scriptevents="1" id="columns_quadprofile"/>
					<quad pos="70.069 -5.970" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar0"/>
					<quad pos="72.672 -3.367" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar1"/>
					<quad pos="71.371 -4.669" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar2"/>
					<quad pos="72.672 -5.970" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar3"/>
					<quad pos="70.069 -3.367" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar4"/>
					<label pos="25.82 -4.67" size="38.53 12.45" halign="left" valign="center2" text="long player name (to check the overflow)" textsize="2.00" class="text-default" id="columns_labelname"/>
					<quad pos="20.62 -4.67" size="7.81 7.81" image="file://Avatars/fsxelw/Default" halign="center" valign="center" id="columns_quadavatar"/>
				</frame>
			</framemodel>
			<quad pos="-0.531 -71.1" z-index="-100" size="322 182" halign="center"	valign="center" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/Dimmer.dds" />
			<quad z-index="-50" size="248.00 166.00" image="file://Media/Manialinks/Trackmania/ScoresTable/bg-canyon.dds" halign="center" hidden="1" id="quadbackground" />
			<frame pos="0 -26" id="frameheader">
				<label pos="-91 -9" z-index="1" size="88 10" text="SCORE" class="text-default" halign="left" valign="center2" textsize="8"/>
				<label pos="-91 -17" size="88 7" textsize="4.5" z-index="3" halign="left" valign="center2" text="RANKING" class="text-default" id="header_title"/>
				<label pos="97.5 -17+" size="94 10" text="$fffEnduroCup" halign="right" textsize="6" id="additionnalinfo_servername" valign="center2" class="text-default"/>
				<quad pos="-94.5 -11.5" z-index="-1" size="1.4 16.5" halign="right" valign="center" bgcolor="fff" />
				<quad pos="41.66 -11.21" size="7.47 7.47" image="" halign="right" valign="center"/>
			</frame>
			<frame id="framefooter" pos="0 -160.50" z-index="1">
				<frame z-index="0">
					<quad z-index="0" size="94 24" halign="center" valign="bottom" style="Bgs1" substyle="BgDialogBlur" opacity="0.35"	pos="0 0"/>
					<quad z-index="1" size="94 24" halign="center" valign="bottom" bgcolor="0b081b" opacity="0.98" />
					<quad pos="-47 24" z-index="2" size="3 3" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderCorner.dds" />
					<quad pos="-46 24" z-index="2" size="93 0.8" rot="180" halign="right" valign="bottom" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderSmall.dds" />
				</frame>
				<frame id="frameplayerinfo" pos="-45 12" z-index="1">
					<quad size="16 16" image="file://Avatars/fsxelw/Default" valign="center" id="playerinfo_avatar" />
					<label pos="17 0" size="10 10" valign="center2" textsize="6" text="#0" class="text-number" id="playerinfo_rank" />
				</frame>
				<frame id="framepager" pos="0 5" z-index="3">
					<quad pos="-12.5 7.7" halign="center" valign="center" size="12 12" scriptevents="1" id="pager_buttonprev" style="UIConstruction_Buttons" substyle="Quit"/>
					<quad pos="12.5 7.7" rot="180" halign="center" valign="center" size="12 12"	style="UIConstruction_Buttons" substyle="Quit" scriptevents="1" id="pager_buttonnext"/>
					<label pos="0 8" size="10 10" z-index="2" halign="center" valign="center2" text="1" id="pager_number" textsize="5"/>
					<quad pos="-15 0.8" size="30 0.6" valign="bottom" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderSmall.dds" />
					<quad pos="15 0.8" size="2 0.6" halign="right" valign="bottom" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderBig.dds" />
				</frame>
				<frame z-index="20" pos="30 5">
					<label pos="0 8" size="10 10" z-index="2" halign="center" valign="center2" text="🔎" scriptevents="1" id="pager_findplayer"	focusareacolor1="0000" focusareacolor2="0000" textsize="5"/>
				</frame>
			</frame>
			<frame id="frametable" pos="0 -49" z-index="1">
				<frameinstance id="framecolumnheader#1" modelid="framemodelcolumnheader" pos="-95.9 1.4" z-index="-1" />
				<frameinstance id="framelegends#1" modelid="framemodellegends" pos="-99.70"/>
				<frameinstance id="scorecard#0" modelid="framemodelscorecard" pos="-99.70 -0.00" />
				<frameinstance id="scorecard#1" modelid="framemodelscorecard" pos="-99.70 -12.45" />
				<frameinstance id="scorecard#2" modelid="framemodelscorecard" pos="-99.70 -24.90" />
				<frameinstance id="scorecard#3" modelid="framemodelscorecard" pos="-99.70 -37.35" />
				<frameinstance id="scorecard#4" modelid="framemodelscorecard" pos="-99.70 -49.80" />
				<frameinstance id="scorecard#5" modelid="framemodelscorecard" pos="-99.70 -62.25" />
				<frameinstance id="framecolumnheader#2" modelid="framemodelcolumnheader" pos="3.1 1.4" z-index="-1" />
				<frameinstance id="framelegends#2" modelid="framemodellegends" pos="-0.50"/>
				<frameinstance id="scorecard#6" modelid="framemodelscorecard" pos="-0.50 -0.00" />
				<frameinstance id="scorecard#7" modelid="framemodelscorecard" pos="-0.50 -12.45" />
				<frameinstance id="scorecard#8" modelid="framemodelscorecard" pos="-0.50 -24.90" />
				<frameinstance id="scorecard#9" modelid="framemodelscorecard" pos="-0.50 -37.35" />
				<frameinstance id="scorecard#10" modelid="framemodelscorecard" pos="-0.50 -49.80" />
				<frameinstance id="scorecard#11" modelid="framemodelscorecard" pos="-0.50 -62.25" />
			</frame>
		</frame>
		<script><!--
			#Include "TextLib" as TextLib
			main () {
				declare netwrite Net_SpecTargetReq for UI = "";
				declare Text PlayerSpec = "";
				declare Integer LatestSpecUpdate = 0;
				declare Integer LatestScoreTableUpdate = 0;
				declare Integer PageIndex = 0;
				declare Integer Blink = -1;
				if ({{{EndRound}}}) Blink = Now;

				// TODO: Load points array from xml
				declare Integer[] PointsArray = [250, 225, 200, 180, 160, 150, 140, 135, 130, 125, 120, 116, 112, 108, 104, 100, 96, 92, 88, 84, 80, 77, 74, 71, 68, 65, 62, 60, 58, 56, 54, 52, 50, 48, 46, 44, 42, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
				declare Integer PointsLast = 0;

				declare CMlQuad quadPlayerAvatar <=> (Page.GetFirstChild("playerinfo_avatar") as CMlQuad);
				declare CMlLabel lblServerName <=> (Page.GetFirstChild("additionnalinfo_servername") as CMlLabel);
				declare CMlLabel lblPageNumber <=> (Page.GetFirstChild("pager_number") as CMlLabel);
				declare CMlLabel lblPlayerRank <=> (Page.GetFirstChild("playerinfo_rank") as CMlLabel);
				quadPlayerAvatar.ImageUrl = "file://Avatars/"^LocalUser.Login^"/Default";
				lblServerName.Value = CurrentServerName;
				if (InputPlayer != Null) {
					if (!InputPlayer.RequestsSpectate) {
						PageIndex = Scores.keyof(InputPlayer.Score)/12;
						lblPageNumber.Value = TextLib::ToText(PageIndex+1);
					}
				}
				while(True) {
					foreach(Event in PendingEvents)	{
						switch(Event.Type) {
							case CMlEvent::Type::MouseClick: {
								if (Event.ControlId == "columns_quadspec") {
									declare TargetSpec for Event.Control = "";
									if (TargetSpec == "")
										continue;
									SetSpectateTarget(TargetSpec);
									Net_SpecTargetReq = TargetSpec;
								} else if (Event.ControlId == "columns_quadprofile") {
									declare TargetProfile for Event.Control = "";
									if (TargetProfile == "")
										continue;
									ShowProfile(TargetProfile);
								} else if (Event.ControlId == "pager_buttonprev") {
									if (PageIndex < 1) continue;
									PageIndex -= 1;
									lblPageNumber.Value = TextLib::ToText(PageIndex+1);
									LatestScoreTableUpdate = 0;
								} else if (Event.ControlId == "pager_buttonnext") {
									if ((PageIndex+1)*12 >= Scores.count) continue;
									PageIndex += 1;
									lblPageNumber.Value = TextLib::ToText(PageIndex+1);
									LatestScoreTableUpdate = 0;
								} else if (Event.ControlId == "pager_findplayer") {
									PageIndex = Scores.keyof(InputPlayer.Score)/12;
									lblPageNumber.Value = TextLib::ToText(PageIndex+1);
									Blink = Now;
									LatestScoreTableUpdate = 0;
								}
							}
							case CMlEvent::Type::MouseOver: {
								if (Event.ControlId == "pager_findplayer") {
									(Event.Control as CMlLabel).TextColor = <0.8, 0.8, 0.8>;
								}
							}
							case CMlEvent::Type::MouseOut: {
								if (Event.ControlId == "pager_findplayer") {
									(Event.Control as CMlLabel).TextColor = <1., 1., 1.>;
								}
							}
						}
					}

					if (LatestScoreTableUpdate + {{{C_UITickPeriod}}} < Now) {
						if (InputPlayer != Null) lblPlayerRank.Value = "#"^(Scores.keyof(InputPlayer.Score)+1);
						
						foreach (Player in Players) { // (MP bug: not detecting fakeplayers when next map)
							declare LastStatusUpdate for Player.User = Now;
							LastStatusUpdate = Now;
							declare Status for Player.User = 2;
							if (Player.RequestsSpectate) Status = 3;
							else if (!Player.IsSpawned) Status = 2;
							else Status = 1;
						}

						for(i, 0, 11) {
							declare CMlFrame frmScoreCard <=> (Page.GetFirstChild("scorecard#"^i) as CMlFrame);
							declare Integer p = PageIndex*12+i;
							if (Scores.existskey(p)) {
								frmScoreCard.Show();
								
								// Variables
								declare CMlLabel lblScore <=> (frmScoreCard.GetFirstChild("columns_labeltmpoints") as CMlLabel);
								declare CMlQuad quadStatus <=> (frmScoreCard.GetFirstChild("scorecard_quadstatus") as CMlQuad);
								declare CMlQuad quadSpec <=> (frmScoreCard.GetFirstChild("columns_quadspec") as CMlQuad);
								declare CMlQuad quadBlink <=> (frmScoreCard.GetFirstChild("scorecard_quadbackgroundblink") as CMlQuad);
								declare LastStatusUpdate for Scores[p].User = Now;
								declare Status for Scores[p].User = 0;

								if (Status == 0 || LastStatusUpdate + {{{C_UITickPeriod}}}*2 < Now) { // Player disconnected
									Status = 0;
									quadStatus.Style = "Icons64x64_2";
									quadStatus.Substyle = "DisconnectedLight";
									quadSpec.Hide();
								} else {
									lblScore.Value = "CP: "^(Scores[p].Points/1000);
									switch (Status) {
										case 1: {
											if ((Scores[p].Points/1000) != (Scores[0].Points/1000)) {
												quadStatus.Style = "Icons64x64_1";
												quadStatus.Substyle = "LvlYellow";
											} else {
												quadStatus.Style = "Icons64x64_1";
												quadStatus.Substyle = "LvlGreen";
											}
											if (!IsSpectatorMode) quadSpec.Hide();
											else quadSpec.Show();
										}
										case 2: {
											quadStatus.Style = "Icons64x64_1";
											quadStatus.Substyle = "LvlRed";
											quadSpec.Hide();
										}
										case 3: {
											quadStatus.Style = "BgRaceScore2";
											quadStatus.Substyle = "Spectator";
											quadSpec.Hide();
										}
									}
								}

								if (Scores[p].User.Login == LocalUser.Login) {
									if (Blink != -1 && Blink + 1500 > Now) {
										quadBlink.Show();
									} else {
										Blink = -1;
										quadBlink.Hide();
									}
								} else {
									quadBlink.Hide();
								}

								// Constants
								declare CMlLabel lblName <=> (frmScoreCard.GetFirstChild("columns_labelname") as CMlLabel);
								if (lblName.Value != Scores[p].User.Name) {
									declare CMlQuad quadAvatar <=> (frmScoreCard.GetFirstChild("columns_quadavatar") as CMlQuad);
									declare CMlLabel lblRank <=> (frmScoreCard.GetFirstChild("scorecard_localrank") as CMlLabel);
									declare CMlLabel lblMultiRank <=> (frmScoreCard.GetFirstChild("scorecard_labelmultirank") as CMlLabel);
									declare CMlQuad quadProfile <=> (frmScoreCard.GetFirstChild("columns_quadprofile") as CMlQuad);
									declare TargetSpec for quadSpec = Scores[p].User.Login;
									declare TargetProfile for quadProfile = Scores[p].User.Login;

									lblName.Value = Scores[p].User.Name;
									quadAvatar.ImageUrl = "file://Avatars/"^Scores[p].User.Login^"/Default";
									lblRank.Value = TextLib::ToText(p+1);
									declare Zone = _("Other");
									declare ZoneArray = TextLib::Split("|", Scores[p].User.LadderZoneName);
									if (ZoneArray.existskey(2)) Zone = ZoneArray[2];
									if (Scores[p].User.LadderRank > 0) lblMultiRank.Value = TextLib::Compose("%1: %2", Zone, TextLib::ToText(Scores[p].User.LadderRank));
									else lblMultiRank.Value = TextLib::Compose("%1: %2", Zone, _("Not ranked"));
									TargetSpec = Scores[p].User.Login;
									TargetProfile = Scores[p].User.Login;
									if ({{{EndRound}}}) {
										declare CMlFrame frmLpGain <=> (frmScoreCard.GetFirstChild("framelpgain") as CMlFrame);
										declare CMlFrame frmPointsGain <=> (frmScoreCard.GetFirstChild("framepointsgain") as CMlFrame);
										declare CMlLabel lblLpGain <=> (frmScoreCard.GetFirstChild("scorecard_labellpgain") as CMlLabel);
										declare CMlLabel lblPointsGain <=> (frmScoreCard.GetFirstChild("scorecard_labelpointsgain") as CMlLabel);
										quadSpec.Hide();
										if (Scores[p].Points != 0) {
											frmLpGain.Show();
											frmPointsGain.Show();
											if (Scores[p].LadderScore != -1.) {
												declare LadderPointsExplode = TextLib::Split(".", TextLib::ToText(Scores[p].LadderScore));
												declare LadderPoints = "+0.00";
												if (LadderPointsExplode.existskey(0)) LadderPoints = LadderPointsExplode[0];
												if (LadderPointsExplode.existskey(1)) LadderPoints ^= "."^TextLib::SubString(LadderPointsExplode[1], 0, 2);
												else LadderPoints ^= ".00";
												if (Scores[p].LadderScore >= 0) lblLpGain.Value = "+"^LadderPoints;
												else lblLpGain.Value = LadderPoints;
											}
											if (PointsArray.existskey(p)) lblPointsGain.Value = "+"^PointsArray[p];
											else lblPointsGain.Value = "+"^PointsLast;
										}
									}
									for(j, 0, 4) {
										declare CMlQuad quadStar <=> (frmScoreCard.GetFirstChild("columns_quadmaniastar"^j) as CMlQuad);
										if ((Scores[p].User.FameStars != 4 && Scores[p].User.FameStars > j) || (Scores[p].User.FameStars == 4 && j != 2)) {
											quadStar.Show();
										} else {
											quadStar.Hide();
										}
									}
								}
							} else {
								frmScoreCard.Hide();
							}
						}
						LatestScoreTableUpdate = Now;
					}

					if (GUIPlayer != Null && (IsSpectatorMode) && LatestSpecUpdate + 1000 < Now) {
						if (PlayerSpec != GUIPlayer.Login) {
							PlayerSpec = GUIPlayer.Login;
							Net_SpecTargetReq = GUIPlayer.Login;
						}
						LatestSpecUpdate = Now;
					}
					yield;
				}
			}
		--></script>
	</manialink>
	""";
		return ML;
}

Text MLGet_Gui(Integer RankPanelType) {
	declare Text ML;
	ML = """
		<script><!--
			#Include "TextLib" as TextLib
			Text GetTime2(Integer RealTime) {
				declare Text r = TextLib::TimeToText(RealTime);
				declare Text b = TextLib::ToText(RealTime+10000);
				r ^= "."^TextLib::SubString(b, TextLib::Length(b)-3, 3);
				return r;
			}
			Integer GetTopIndex(Integer CP) {
				if (CP < 0) return -1;
				declare Integer Points = CP*1000+999;
				if (Scores[0].Points == Points || Scores[0].Points == CP) return 0;
				if (Scores[0].Points < Points) return -1;
				// Binary search
				declare Integer low = 0;
				declare Integer high = Scores.count-1;
				while (low <= high) {
					declare Integer mid = (low + high)/2;
					if ((Scores[mid].Points/1000) == CP) {
						high = mid - 1;
						if ((Scores[high].Points/1000) != CP) return mid; // Lowest (biggest) value found, Scores[high] always exists because index 0 already checked
					}
					else if (Scores[mid].Points > Points) low = mid + 1;
					else high = mid - 1;
				}
				return -1;
			}
			main () {
				declare CMlFrame FrameTimer <=> (Page.GetFirstChild("FrameTimer") as CMlFrame);
				declare CMlFrame PlayingButton <=> (Page.GetFirstChild("PlayingButton") as CMlFrame);
				declare CMlLabel LText <=> (Page.GetFirstChild("LText") as CMlLabel);
				declare CMlLabel LTime <=> (Page.GetFirstChild("LTime") as CMlLabel);
				declare CMlLabel Position <=> (Page.GetFirstChild("Position") as CMlLabel);
				declare CMlLabel TimeDiff <=> (Page.GetFirstChild("TimeDiff") as CMlLabel);
				
				declare LocalCP = 0;
				declare netread Integer Net_State for UI;
				declare netread Integer Net_CP for UI;
				declare Integer CP for UI;
				declare netread Integer[Integer] Net_ReachTimes for UI;
				declare netread Integer Net_DriversLeft for UI;
				declare netread Integer Net_DriversTotal for UI;
				declare UIU = Now;
				declare UiMovementLeft = 0;
				declare Offset = 0;
				""";
				if (RankPanelType == 1)
					ML ^= """
				declare CMlLabel LDriversLeft <=> (Page.GetFirstChild("LDriversLeft") as CMlLabel);
				""";
				ML^= """
				
				declare CMlLabel End_Victory <=> (Page.GetFirstChild("End_Victory") as CMlLabel);
				declare CMlLabel End_Knockout <=> (Page.GetFirstChild("End_Knockout") as CMlLabel);
				declare CMlQuad ReadyIcon <=> (Page.GetFirstChild("_ReadyIcon") as CMlQuad);
				
				declare netread Integer Net_Victory for UI;
				declare netread Integer Net_KnockOut for UI;
				
				declare netread Integer Net_Position for UI;
				
				declare netread Integer Net_TimeDiff for UI;
				declare netread Integer Net_TimeDiffCT for UI;
				
				declare netread Integer Net_AfterCPTimeLeft for UI;
				declare Integer AfterCPTimeLeft;
				declare Integer AfterCPTimeLeftCT;
				declare Integer LastUpdateTime = 0;
				declare netread Text[Integer] Net_MsgText for UI;
				declare Text[] PrevMsgText;
				declare netread Integer[Integer] Net_MsgTextTime for UI;
				declare Integer PrevMsgTextTime = 0;
				declare Integer Ignore = 0;
				declare CMlLabel[Integer] statusls;
				for (i, 0, 4) {
					declare bit <=> (Page.GetFirstChild("Status"^i) as CMlLabel);
					statusls[i] = bit;
				}
				declare Integer animation;
				while(True) {
					if (UIU + 100 < Now) {
						if (InputPlayer != Null && (IsSpectatorMode || Net_State == 0)) {
							PlayingButton.Show();
							if (!InputPlayer.RequestsSpectate)
								ReadyIcon.Substyle = "LvlGreen";
							else
								ReadyIcon.Substyle = "LvlRed";
						} else {
							PlayingButton.Hide();
						}
						Position.SetText("$08f"^Net_Position);
						""";
						if (RankPanelType == 1)
							ML ^= """
						declare FrameCount = 0;
						for (i, -2, 1) {
							declare P_CP = Net_CP+i;
							declare findex = GetTopIndex(P_CP);
							if (findex == -1) continue;
							declare k = 0;
							declare s = 0;
							if (i == 1) s = 9;
							for (j, s, 9) {
								declare index = findex-(j-9);
								if (Scores.existskey(index) && (Scores[index].Points/1000) == P_CP) {
									declare CMlFrame PFrame <=> (Page.GetFirstChild("Bar_"^FrameCount) as CMlFrame);
									FrameCount = FrameCount + 1;
									declare Status for Scores[index].User = 0;
									declare CMlQuad quadStatus <=> (PFrame.GetFirstChild("Status") as CMlQuad);
									if (Status == 1) {
										if (P_CP != (Scores[0].Points/1000)) {
											quadStatus.Substyle = "LvlYellow";
										} else {
											quadStatus.Substyle = "LvlGreen";
										}
									} else {
										quadStatus.Substyle = "LvlRed";
									}
									declare CMlLabel lblName <=> (PFrame.GetFirstChild("Name") as CMlLabel);
									lblName.Value = Scores[index].User.Name;
									declare YPos = ((P_CP*20+29)+Offset-UiMovementLeft*2)+k;
									k = k + 2;
									PFrame.PosnY -= (PFrame.PosnY-(YPos)*1.)/10.;
									PFrame.Show();
								} else {
									continue;
								}
							}
						}
						while (FrameCount <= 30) {
							declare CMlFrame PFrame <=> (Page.GetFirstChild("Bar_"^FrameCount) as CMlFrame);
							PFrame.Hide();
							FrameCount = FrameCount + 1;
						}
						LDriversLeft.SetText("$383"^Net_DriversLeft^"$fff/$888"^Net_DriversTotal);
						if (UiMovementLeft != 0) {
							declare UiMovementDirection = 0;
							if (UiMovementLeft > 0) {
								UiMovementDirection = 1;
							} else {
								UiMovementDirection = UiMovementLeft; // Instant
							}
							UiMovementLeft -= UiMovementDirection;
							for (i, -2, 1) {
								declare CMlLabel L <=> (Page.GetFirstChild("CPL"^i) as CMlLabel);
								declare CMlQuad Q <=> (Page.GetFirstChild("CPQ"^i) as CMlQuad);
								L.PosnY -= UiMovementDirection;
								Q.PosnY -= UiMovementDirection;
								if (i == -1) {
									L.Hide();
									Q.Hide();
								}
							}
							Offset -= UiMovementDirection;
							if (UiMovementLeft == 0) {
								for (i, -2, 1) {
									declare CMlLabel L <=> (Page.GetFirstChild("CPL"^i) as CMlLabel);
									declare CMlQuad Q <=> (Page.GetFirstChild("CPQ"^i) as CMlQuad);
									L.PosnY = 20.*i+10.;
									Q.PosnY = 20.*i+10.;
									if (i == -1) {
										L.Show();
										Q.Show();
									}
									if (CP+i == 0)
										L.SetText("$000$sStart");
									else if (CP+i <= -1)
										L.SetText("");
									else
										L.SetText("$000$sCP "^CP+i);
								}
							}
						}
						for (i, -2, 0) {
							declare CMlLabel L <=> (Page.GetFirstChild("CPCL"^i) as CMlLabel);
							declare CMlQuad Q <=> (Page.GetFirstChild("CPCQ"^i) as CMlQuad);
							if (Net_ReachTimes.existskey(CP+i+1)) {
								if ((Net_ReachTimes[CP+i+1]-GameTime) > 0) {
									L.SetText("$f00$s"^(Net_ReachTimes[CP+i+1]-GameTime)/1000^"");
								} else {
									L.SetText("$000$sXXX");
								}
								Q.Show();
							} else {
								L.SetText("");
								Q.Hide();
							}
						}""";
						ML^="""
					}
					if (Net_MsgTextTime.existskey(0) && Net_MsgTextTime[0] != PrevMsgTextTime) {
						//PrevMsgText = Net_MsgText;
						PrevMsgTextTime = Net_MsgTextTime[0];
						log("RECV "^Net_MsgTextTime[0]^" gt "^GameTime);
						//if (Now > Ignore+1000) {
						log("k");
						if (Net_MsgText.existskey(0)) {
							log("yy" ^ Net_MsgText[0]);
							statusls[4].SetText(Net_MsgText[4]);
							statusls[3].SetText(Net_MsgText[3]);
							statusls[2].SetText(Net_MsgText[2]);
							statusls[1].SetText(Net_MsgText[1]);
							statusls[0].SetText(Net_MsgText[0]);
							//statusts[4] = statusts[3]; // Can be improved
							//statusts[3] = statusts[2];
							//statusts[2] = statusts[1];
							//statusts[1] = statusts[0];
							//statusts[0] = Now;
							animation = Now;
							LastUpdateTime = 0;
						}
						//}
					}
					if (Net_MsgTextTime.existskey(0) && LastUpdateTime + 25 < Now) {
						declare Real animationTad = 4.;
						// Generic stud callover: (statusls[0].Scale/1.2)
						// Net_StreakScore_ => New streakscore
						// StreakFrom => Old streakscore
						// Net_StreakScore_ - StreakFrom => Difference, /2 => addition to StreakFrom
						if (Now <= animation+200)
							animationTad = (Now-animation)/50.;
						//	statusls[0].Scale = ((Now-animation)/500.)*0.8;
						//} else
						//	statusls[0].Scale = 1.2;
						for (i, 0, 4) {
							statusls[i].PosnY = -46.0+i*3.9+animationTad;
							if (GameTime > Net_MsgTextTime[i]+4500) {
								statusls[i].Scale = 0.;
								//log("bye " ^ Net_MsgTextTime[i] ^ "-"^GameTime);
							} else if (GameTime > Net_MsgTextTime[i]+4000) {
								statusls[i].Scale = 0.8-((GameTime-Net_MsgTextTime[i]-4000)/500.)*0.8;
							} else if (GameTime > Net_MsgTextTime[i]+500) {
								statusls[i].Scale = 0.8;
							} else {
								statusls[i].Scale = ((GameTime-Net_MsgTextTime[i])/500.)*0.8;
							}
						}
						
						LastUpdateTime = Now;
					}
					if (Net_CP != CP && UiMovementLeft == 0) {
						if (Net_CP > CP) {
							UiMovementLeft = 20;
							CP += 1;
						} else {
							UiMovementLeft = -20*(CP-Net_CP);
							CP = Net_CP;
						}
					}
					// important data, no delay
					if (!Net_ReachTimes.existskey(Net_CP+1)) {
						LText.SetText("$fff$sCheckpoint reached!");
						if (Net_AfterCPTimeLeft != AfterCPTimeLeft) {
							AfterCPTimeLeft = Net_AfterCPTimeLeft;
							AfterCPTimeLeftCT = Now;
						}
						if (AfterCPTimeLeftCT + 2000 < Now)
							FrameTimer.PosnY += (105-FrameTimer.PosnY)/20.;
						LTime.SetText("$f33"^GetTime2(Net_AfterCPTimeLeft));
						UI.UISequence = CUIConfig::EUISequence::None;
					} else if (Net_ReachTimes[Net_CP+1]-GameTime <= 0) {
						FrameTimer.PosnY += (90-FrameTimer.PosnY)/8.;
						LText.SetText("$s$fffReach $f00CP "^Net_CP+1^"$fff within...");
						LTime.SetText("$f330:00.000");
						UI.UISequence = CUIConfig::EUISequence::Outro;
					} else {
						FrameTimer.PosnY += (90-FrameTimer.PosnY)/8.;
						LText.SetText("$s$fffReach $f00CP "^Net_CP+1^"$fff within...");
						LTime.SetText("$f33"^GetTime2(Net_ReachTimes[Net_CP+1]-GameTime));
						UI.UISequence = CUIConfig::EUISequence::None;
					}
					if (Net_TimeDiffCT != 0 && Net_TimeDiffCT + 2000 > GameTime) {
						TimeDiff.Show();
						if (Net_TimeDiff < 0) {
							TimeDiff.SetText("$00f"^GetTime2(Net_TimeDiff));
						} else {
							TimeDiff.SetText("$f00+"^GetTime2(Net_TimeDiff));
						}
					} else
						TimeDiff.Hide();
					if (IsSpectatorMode || Net_State == 0) {
						foreach(Event in PendingEvents)	{
							if (Event.Type == CMlEvent::Type::MouseClick) {
								if (Event.ControlId == "_Ready") {
									ShowInGameMenu();
								}
							}
						}
					}
					yield;
				}
			}
		--></script>""";
		if (RankPanelType == 1) {
		ML ^= """
		<frame posn="1 0 1" id="FrameRules">
			<label posn="0 -24 31" scale="1" halign="center" valign="center" text="" id="CName " Scale="0.8" />
			<!--Bar-->
			<quad sizen="2 62 0" posn="149 31 1" style="Bgs1" substyle="BgColorContour" />
			<!--<quad bgcolor="08fb" sizen="1 1" posn="150 32 1" valign="center" halign="center"/>
			<quad bgcolor="08f8" sizen="1 1" posn="150 33 1" valign="center" halign="center"/>
			<quad bgcolor="08f4" sizen="1 1" posn="150 34 1" valign="center" halign="center"/>-->
			<quad bgcolor="08f" sizen="1 60" posn="150 -1 1" valign="center" halign="center"/>
			
			<!--Inc CPs-->
			<!--<quad bgcolor="800" sizen="3 3" posn="150 30 2" valign="center" halign="center" id="CPQ2"/>-->
			<quad style="Icons128x32_1" substyle="RT_Rounds" sizen="6 6" posn="150 30 2" valign="center" halign="center" id="CPQ1"/>
			<label text="$000$sCP 1" style="TextPlayerCardScore" posn="147 30 3" valign="center" halign="right" scale="1" id="CPL1"/>
			
			<quad style="Icons128x32_1" substyle="RT_Rounds" sizen="6 6" posn="150 10 2" valign="center" halign="center" id="CPQ0"/>
			<label text="$000$sStart" style="TextPlayerCardScore" posn="147 10 3" valign="center" halign="right" scale="1" id="CPL0"/>
			<!--Prev CPs-->
			<!--Current CP-->
			<!--Prev CPs-->
			<quad style="Icons128x32_1" substyle="RT_Rounds" sizen="6 6" posn="150 -10 2" valign="center" halign="center" id="CPQ-1"/>
			<label text="" style="TextPlayerCardScore" posn="147 -10 3" valign="center" halign="right" scale="1" id="CPL-1"/>
			
			<quad style="Icons128x32_1" substyle="RT_Rounds" sizen="6 6" posn="150 -30 2" valign="center" halign="center" id="CPQ-2"/>
			<label text="" style="TextPlayerCardScore" posn="147 -30 3" valign="center" halign="right" scale="1" id="CPL-2"/>
			<!--Incoming CPs-->
			
			<!-- <label text="$s$o0" posn="150 -34 3" valign="center" halign="center" scale="0.7" id="LUnder"/> -->
			<!-- <quad posn="151 -30 3" sizen="8 8" style="UIConstruction_Buttons" substyle="Drive" /> -->
			<!-- <label text="$s$o0" posn="150 34 3" valign="center" halign="center" scale="0.7" id="LAbove"/> -->
			<!-- <quad posn="151 38 3" sizen="8 8" style="UIConstruction_Buttons" substyle="Drive" /> -->
			
			<!--CPStates-->
			
			<quad bgcolor="f77" sizen="1 18" posn="150 20 2" valign="center" halign="center" id="CPCQ0"/>
			<label text="$f00$s" style="TextPlayerCardScore" posn="151 20 3" valign="center" halign="left" scale="1.5" id="CPCL0"/>
			
			<quad bgcolor="f77" sizen="1 18" posn="150 0 2" valign="center" halign="center" id="CPCQ-1"/>
			<label text="$f00$s" style="TextPlayerCardScore" posn="151 0 3" valign="center" halign="left" scale="1.5" id="CPCL-1"/>
			
			<quad bgcolor="f77" sizen="1 18" posn="150 -20 2" valign="center" halign="center" id="CPCQ-2"/>
			<label text="$f00$s" style="TextPlayerCardScore" posn="151 -20 3" valign="center" halign="left" scale="1.5" id="CPCL-2"/>
			
			<label text="$s$i$08fDrivers left:" posn="153 -37 3" valign="center" halign="center" scale="0.45"/>
			<label style="TextValueSmallSm" text="$3830$fff/$8880" posn="153 -40 3" valign="center" halign="center" scale="1" id="LDriversLeft"/>
			
			<!--User Frames-->
			""";
			for (i, 0, 30) {
				ML^="""<frame posn="0 0 1" id="Bar_{{{i}}}">
				<quad style="Icons64x64_1" substyle="LvlRed" sizen="4 3" posn="150 -17 6" valign="center" halign="center" id="Status"/>
				<label text="$splayer" posn="148 -17 5" valign="center" halign="right" scale="0.5" id="Name"/>
				</frame>""";
			}
		ML^="""</frame>""";
		}
		ML^="""
		<frame posn="0 90 1" id="FrameTimer">
			<!--<quad sizen="66 15 1" posn="-33 0.1 0" style="UiSMSpectatorScoreBig" substyle="CenterShield" />--><!-- It's a little too appearant imo.. -->
			<!--<quad style="Bgs1InRace" substyle="BgHealthBar" sizen="50 6" posn="-25 -0.5 2"/>-->
			<label text="$s$o$fffReach $f00CP 0$fff within..." posn="0 -3 5" valign="center" halign="center" scale="0.3" id="LText" style="TextRaceMessageBig"/>
			<label text="$f000:00.000" posn="0 -8 5" valign="center" halign="center" style="TextRaceChrono" scale="0.8" id="LTime"/>
		</frame>
		<label text="$FB2$o$sVICTORY" scale="0" posn="0 110 10" valign="center" halign="center" textsize="10" id="End_Victory"/>
		<label text="$f33$o$sKNOCKED OUT" scale="0" posn="0 110 10" valign="center" halign="center" textsize="7" id="End_Knockout"/>
		
		<label text="$08f0" posn="153 -48 10" valign="center" halign="right" style="TextRaceChrono" textsize="10" id="Position"/>
		<label text="$00f+0:00.00" posn="0 27.5 10" sizen="16 0" valign="center" halign="center" style="TextRaceChrono" textsize="4" id="TimeDiff"/>
		<frame posn="0 -75 1" id="PlayingButton">
			<quad style="Icons64x64_1" substyle="LvlGreen" sizen="7 7" posn="-13 0 31" valign="center" id="_ReadyIcon" halign="center"/>
			<label text="    Playing" valign="center" halign="center" style="TextButtonNav"/>
			<quad valign="center" halign="center" sizen="40 8" style="BgsPlayerCard" substyle="BgPlayerCardSmall" id="_Ready" scriptevents="1"/>
		</frame>
		""";
		ML ^= """
		<label valign="center" id="Status0" text="$s$o$fff" posn="-157 -34" scale="0.7" textemboss="true" />
		<label valign="center" id="Status1" text="$s$o$fff" posn="-157 -37" scale="0.7" textemboss="true" />
		<label valign="center" id="Status2" text="$s$o$fff" posn="-157 -40" scale="0.7" textemboss="true" />
		<label valign="center" id="Status3" text="$s$o$fff" posn="-157 -43" scale="0.7" textemboss="true" />
		<label valign="center" id="Status4" text="$s$o$fff" posn="-157 -46" scale="0.7" textemboss="true" />
	""";
		return ML;
}

Void ThrowMsg(CUIConfig UI, Text Msg, Boolean Force) {
	declare netwrite Text[Integer] Net_MsgText for UI;
	declare netwrite Integer[Integer] Net_MsgTextTime for UI;
	//if (Force || Now-Net_MsgTextTime > 100) {
		if (!Net_MsgText.existskey(4)) {
			Net_MsgText[4] = "";Net_MsgText[3] = "";Net_MsgText[2] = "";Net_MsgText[1] = "";Net_MsgText[0] = "";
			Net_MsgTextTime[4] = 0;Net_MsgTextTime[3] = 0;Net_MsgTextTime[2] = 0;Net_MsgTextTime[1] = 0;Net_MsgTextTime[0] = 0;
		}
		Net_MsgText[4] = Net_MsgText[3];
		Net_MsgText[3] = Net_MsgText[2];
		Net_MsgText[2] = Net_MsgText[1];
		Net_MsgText[1] = Net_MsgText[0];
		Net_MsgText[0] = Msg;
		Net_MsgTextTime[4] = Net_MsgTextTime[3];
		Net_MsgTextTime[3] = Net_MsgTextTime[2];
		Net_MsgTextTime[2] = Net_MsgTextTime[1];
		Net_MsgTextTime[1] = Net_MsgTextTime[0];
		Net_MsgTextTime[0] = Now;
		// log("THROW MSG" ^ Net_MsgTextTime[0]);
	//}
}

Void ThrowMsgAll(Text Msg, Boolean Force) {
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		ThrowMsg(UI, Msg, Force);
	}
}

Void ResetAll() {
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare Integer CP for Player;
		CP = 0;
		declare Integer CP as CPScore for Player.Score;
		CPScore = CP;
		declare Integer Round for Player;
		Round = 0;
		declare netwrite Integer Net_CP for UI;
		Net_CP = CP;
		declare netwrite Integer Net_Victory for UI;
		Net_Victory = 0;
		declare netwrite Integer Net_KnockOut for UI;
		Net_KnockOut = 0;
		declare netwrite Integer Net_Position for UI;
		Net_Position = 1;
	}
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		
		UI.UILayers.clear();
		declare LayerGui <=> UIManager.UILayerCreate();
		LayerGui.Type = CUILayer::EUILayerType::Normal;
		UI.UILayers.add(LayerGui);
	}
}

Void Synchro() {
	declare Text StatusMsg = UIManager.UIAll.StatusMessage;
	UIManager.UIAll.StatusMessage = "Synchronization...";
	declare Barrier = Synchro_AddBarrier();
	while (!Synchro_BarrierReached(Barrier) && !ServerShutdownRequested) yield;
	UIManager.UIAll.StatusMessage = StatusMsg;
}

Void WaitPass(Integer TimePass) {
	Synchro();
	while (TimePass > Now) {
		foreach (E in PendingEvents) {
			switch (E.Type) {
				case CTmModeEvent::EType::GiveUp:
					Discard(E);
				case CTmModeEvent::EType::WayPoint: 
					Discard(E);
				default:
					PassOn(E);
			}
		}
		yield;
	}
}

main() {
	log("== Restart ==");
	log("Mode: EnduroCup");
	log("Version: "^Version);
	log("Original author: TGYoshi");
	log("Modified for cup by: Virtex");
	log("=============");

	ModeInfo::SetName("Enduro Cup");
	ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
	ModeInfo::SetRules(Description);
	ModeInfo::SetStatusMessage(StatusMessage);

	declare netwrite version for XmlRpc = Version;
	version = Version;
	declare netwrite enduro_scores for XmlRpc = "";
	enduro_scores = "";
	declare netread decreaser for XmlRpc = TimeMargeP2;
	declare netread sim_cptime for XmlRpc = SimulateFakeplayerCP;
	declare netread Boolean last_round for XmlRpc = False;
	IndependantLaps = False;
	NbLaps = 0;
	UiRounds = True;
	RespawnBehaviour = CTmMode::ETMRespawnBehaviour::Normal;

	declare LayerScoresTable	<=> UIManager.UILayerCreate();
	LayerScoresTable.Type = CUILayer::EUILayerType::ScoresTable;

	UIManager.UIAll.ScoreTableOnlyManialink = True;
	UIManager.UIAll.ScoreTable = "";
	UIManager.UIAll.SmallScoreTable = "";
	declare Integer ReachCP;
	declare Integer[Integer] ReachTimes;
	declare Integer[Integer] PlayersReached;
	declare Text     CtWarmingUp = DfWarmingUp;
	declare Boolean  CtHideWarmingUpStatus = False;
	declare Integer  CtRankPanelType = 1;
	declare Boolean  CtPermitStarting = True;
	declare Boolean new_map = False;

	while (!ServerShutdownRequested) {
		log("== New Round ==");
		if (!MapLoaded) {
			RequestLoadMap();
			Scores_Clear();
			new_map = True;
		} else {
			new_map = False;
		}
		wait(MapLoaded);
		foreach (Player in AllPlayers) {
			// Reset
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			UI.ForceSpectator = False;
		}
		Synchro();
		UIManager.UIAll.StatusMessage = "Please wait...";
		ResetAll();
		ReachCP = 0;
		ReachTimes.clear();
		declare MapWinnerId = NullId;
		MatchEndRequested = False;
		if (new_map) {
			UIManager.UIAll.UISequence = CUIConfig::EUISequence::Intro;
			UIManager.UIAll.BigMessage = "";
			UIManager.UIAll.StatusMessage = "";
			if (SkipIntro != 1)
				wait(UIManager.UIAll.UISequenceIsCompleted);
		}
		UIManager.ResetAll();
		UIManager.UIAll.ScoreTableOnlyManialink = True;
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
		// UIManager.UIAll.UILayers.clear();
		declare LayersToRemove = Ident[];
		foreach (Layer in UIManager.UILayers) {
			if (Layer.Id != LayerScoresTable.Id) {
				LayersToRemove.add(Layer.Id);
			}
		}
		foreach (LayerId in LayersToRemove) {
			UIManager.UILayerDestroy(UIManager.UILayers[LayerId]);
		}
		UIManager.UIAll.UILayers.add(LayerScoresTable);
		LayerScoresTable.ManialinkPage = MLGet_ScoreTable(False);
		UIManager.UIAll.BigMessage = CtWarmingUp;
		declare Integer StartingAt = 0;
		XmlRpc.SendCallback_BeginRound();
		WarmUp::Begin();
		declare Integer LatestUiUpdate = Now;
		while (!MatchEndRequested) {
			foreach (Player in AllPlayers) {
				if (new_map) {
					declare Integer BestTime for Player;
					BestTime = -1;
					declare Integer[Integer] BestCPTimes for Player;
					BestCPTimes.clear();
				}
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				declare netwrite Integer Net_State for UI;
				Net_State = 0;
				UI.UISequence = CUIConfig::EUISequence::None;
				declare Integer CP for Player;
				CP = 0;
				declare Integer CP as CPScore for Player.Score;
				CPScore = CP;
				declare netwrite Integer Net_ReachCP for UI;
				Net_ReachCP = 0;
				declare netwrite Integer Net_Position for UI;
				Net_Position = 0;
				declare netwrite Integer Net_DriversLeft for UI;
				Net_DriversLeft = 0;
				declare netwrite Integer Net_DriversTotal for UI;
				Net_DriversTotal = 0;
				declare netwrite Integer[Integer] Net_ReachTimes for UI;
				Net_ReachTimes = ReachTimes;
				declare netwrite Integer Net_AfterCPTimeLeft for UI;
				Net_AfterCPTimeLeft = 0;
				
				if (UI.UILayers.count != 1) {
					UI.UILayers.clear();
					declare LayerGui <=> UIManager.UILayerCreate();
					LayerGui.Type = CUILayer::EUILayerType::Normal;
					UI.UILayers.add(LayerGui);
					LayerGui.ManialinkPage = MLGet_Gui(CtRankPanelType);
				}
			}
			foreach (Player in PlayersWaiting) {
				Player.RaceStartTime = Now+3000;
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				ThrowMsg(UI, "$2c2"^(WarmupTime/1000)^" seconds warming up", False);
			}
			if (CtHideWarmingUpStatus) {
				UIManager.UIAll.StatusMessage = "";
				if (!CtPermitStarting || Players.count < PlayersReq)
					StartingAt = 0;
				else if (StartingAt == 0)
					StartingAt = Now+WarmupTime;
			} else {
				if (!CtPermitStarting) {
					UIManager.UIAll.StatusMessage = "Match start prohibited.";
					StartingAt = 0;
				} else if (Players.count < PlayersReq) {
					UIManager.UIAll.StatusMessage = "At least "^PlayersReq^" players required to start. ("^PlayersRacing.count^"/"^PlayersReq^")";
					StartingAt = 0;
				} else {
					if (StartingAt == 0)
						StartingAt = Now+WarmupTime;
					UIManager.UIAll.StatusMessage = "Starting in "^(StartingAt-Now)/1000^" seconds...";
				}
			}
			foreach (E in XmlRpc.PendingEvents) {
				if (E.Type != CXmlRpcEvent::EType::Callback)
					continue;
				switch (E.Param1) {
					case "Endurance.StartMatch": {
						StartingAt = 1;
						break;
					}
					case "Endurance.CtSet.WarmingUp": {
						CtWarmingUp = E.Param2;
					}
					case "Endurance.CtSet.RankPanelType": {
						CtRankPanelType = TextLib::ToInteger(E.Param2);
						if (CtRankPanelType < 0 || CtRankPanelType > 1)
							CtRankPanelType = 0;
					}
					case "Endurance.CtSet.HideWarmingUpStatus": {
						CtHideWarmingUpStatus = (E.Param2 == "True" || E.Param2 == "true" || E.Param2 == "1");
					}
					case "Endurance.CtSet.PermitStarting": {
						CtPermitStarting = (E.Param2 == "True" || E.Param2 == "true" || E.Param2 == "1");
					}
					case "Endurance.ThrowMessageAll": {
						ThrowMsgAll(E.Param2, False);
					}
				}
			}
			CutOffTimeLimit = StartingAt;
			if ((StartingAt-Now) <= 0 && StartingAt != 0)
				break;
			UIManager.UIAll.BigMessage = CtWarmingUp;
			yield;
		}
		WarmUp::End();
		CutOffTimeLimit = 0;
		declare Boolean winner = False;
		UIManager.UIAll.BigMessage = "";
		Synchro();
		if (!MatchEndRequested && !ServerShutdownRequested) {
			UIManager.UIAll.StatusMessage = "Starting...";
			Scores_Clear();
			
			foreach (Player in PlayersRacing) {
				Player.RaceStartTime = 0;
			}
			Ladder_CancelMatchRequest();
			wait(!Ladder_RequestInProgress); 
			
			Ladder_OpenMatch_BeginRequest(); 
			foreach(Score in Scores) {
				Ladder_OpenMatch_AddPlayer(Score); 
			}
			Ladder_OpenMatch_EndRequest(); 
			wait(!Ladder_RequestInProgress); 

			ReachCP = 0;
			ReachTimes.clear();
			foreach (Player in AllPlayers) {
				// Reset
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				UI.ForceSpectator = False;
				declare netwrite Integer Net_State for UI;
				Net_State = 1;
			}

			if (last_round == True)
				ThrowMsgAll("$z$w$s$F00LIVE! $z$s$2c2LAST ROUND has started, GLHF!", True);
			else
				ThrowMsgAll("$z$w$s$F00LIVE! $z$s$2c2Round has started, GLHF!", True);

			UIManager.UIAll.StatusMessage = "";
			// Match start
			UIManager.UIAll.CountdownEndTime = 0;

			declare RoundEndRequested = False;
			declare LastUIUpdateTime = -C_UITickPeriod;
			PlayersReached.clear();

			foreach (Player in AllPlayers) {
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				declare Integer CP for Player;
				CP = 0;
				declare Integer CP as CPScore for Player.Score;
				CPScore = CP;
				declare Integer Round for Player;
				Round = 0;
				declare netwrite Integer Net_CP for UI;
				Net_CP = CP;
				declare netwrite Integer Net_Victory for UI;
				Net_Victory = 0;
				declare netwrite Integer Net_KnockOut for UI;
				Net_KnockOut = 0;
				declare netwrite Integer Net_Position for UI;
				Net_Position = 1;
				Player.Score.Clear();
				if (Players.exists(Player)) {
					Player.RaceStartTime = Now+5000;
					declare Integer LapStart for Player = 0;
					LapStart = Player.RaceStartTime;
					Player.Score.Points = 0;
				}
			}
			foreach (Player in AllPlayers) {
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				
				UI.UILayers.clear();
				declare LayerGui <=> UIManager.UILayerCreate();
				LayerGui.Type = CUILayer::EUILayerType::Normal;
				UI.UILayers.add(LayerGui);
				LayerGui.ManialinkPage = MLGet_Gui(CtRankPanelType);
			}
			declare Integer TimeMarge = TimeMargeP1;
			declare Text Leader = "";
			declare Text LeaderNickName = "";
			EndLatestKO = "";
			EndWinner = "";
			declare Integer LatestDebugFPUpdate = 0;
			while( True ) {
				yield;
				// Simulate with fakeplayers (debug)
				declare CTmPlayer[] FakePlayers;
				if (sim_cptime > 0 && LatestDebugFPUpdate + sim_cptime < Now) {
					foreach (Player in AllPlayers) {
						if (TextLib::SubString(Player.User.Login,0,11) == "*fakeplayer") {
							if (Player.RaceStartTime != 0) FakePlayers.add(Player);
						}
					}
					if (FakePlayers.count > 0) {
						declare FakePlayer <=> FakePlayers[MathLib::Rand(0,FakePlayers.count-1)];
						declare UI <=> UIManager.GetUI(FakePlayer);
						if (UI == Null) continue;
						declare Integer CP for FakePlayer;
						declare Integer LapStart for FakePlayer = 0;
						CP += 1;
						declare Integer CP as CPScore for FakePlayer.Score;
						CPScore = CP;
						if (!PlayersReached.existskey(CP)) PlayersReached[CP] = 0;
						PlayersReached[CP] = PlayersReached[CP] + 1;
						declare netwrite Integer Net_Position for UI;
						Net_Position = PlayersReached[CP];

						declare netwrite Integer Net_CP for UI;
						Net_CP = CP;
						if (PlayersReached[CP] > 1000)
							FakePlayer.Score.Points = CP*1000;
						else
							FakePlayer.Score.Points = CP*1000 + (1000-PlayersReached[CP]);
						if (CP > ReachCP) {
							ReachCP = CP;
							ReachTimes[CP] = Now+TimeMarge;
							TimeMarge = MathLib::NearestInteger((TimeMarge*1.)*decreaser);
							if (Leader != FakePlayer.User.Login) {
								Leader = FakePlayer.User.Login;
								LeaderNickName = FakePlayer.User.Name;
								ThrowMsgAll(FakePlayer.User.Name^"$z$2c2$s takes the lead!", True);
							}
						}
					}
					LatestDebugFPUpdate = Now;
				}
				foreach (E in PendingEvents) {
					switch (E.Type) {
						case CTmModeEvent::EType::GiveUp:
							Discard(E);
						case CTmModeEvent::EType::WayPoint: {
							if (E.Player.RaceStartTime == 0 || E.RaceTime == 0) {
								log("Unknown driver "^E.Player.User.Login);
								Discard(E);
								continue;
							}
							declare UI <=> UIManager.GetUI(E.Player);
							if (UI == Null) continue;
							declare netwrite Integer[Integer] Net_ReachTimes for UI;
							declare Integer CP for E.Player;
							if (Net_ReachTimes.existskey(CP+1)) {
								if (Net_ReachTimes[CP+1]-E.Player.RaceStartTime-E.RaceTime <= 0) {
									// is out anyway
									ThrowMsg(UI, "$z$2c2$sYou're eliminated! ($f00+"^GetTime2(-1*(Net_ReachTimes[CP+1]-E.Player.RaceStartTime-E.RaceTime))^"$2c2)", True);
									Discard(E);
									continue;
								} else {
									declare netwrite Integer Net_AfterCPTimeLeft for UI;
									//Net_AfterCPTimeLeft = Net_ReachTimes[CP+1]-Now;
									Net_AfterCPTimeLeft = Net_ReachTimes[CP+1]-E.Player.RaceStartTime-E.RaceTime;
								}
							}
							declare Integer LapStart for E.Player = 0;
							CP += 1;
							declare Integer CP as CPScore for E.Player.Score;
							CPScore = CP;
							if (!PlayersReached.existskey(CP)) PlayersReached[CP] = 0;
							PlayersReached[CP] = PlayersReached[CP] + 1;
							declare netwrite Integer Net_Position for UI;
							Net_Position = PlayersReached[CP];

							declare netwrite Integer Net_CP for UI;
							Net_CP = CP;
							// if (E.Player.Score.Points < CP)
							if (PlayersReached[CP] > 1000)
								E.Player.Score.Points = CP*1000;
							else
								E.Player.Score.Points = CP*1000 + (1000-PlayersReached[CP]);
							
							// If leader, set a new global goal //
							if (CP > ReachCP) {
								ReachCP = CP;
								ReachTimes[CP] = Now+TimeMarge;
								TimeMarge = MathLib::NearestInteger((TimeMarge*1.)*decreaser);
								if (Leader != E.Player.User.Login) {
									Leader = E.Player.User.Login;
									LeaderNickName = E.Player.User.Name;
									ThrowMsgAll(E.Player.User.Name^"$z$2c2$s takes the lead!", True);
								}
							}
							
							PassOn(E);
							
							declare Integer RoundCP = E.Player.CurLap.Checkpoints.count-1;
							declare Integer BestTime for E.Player;
							declare Integer[Integer] BestCPTimes for E.Player;
							if (BestTime > 3000 || (BestCPTimes.existskey(RoundCP) && BestTime == -1)) {
								declare netwrite Integer Net_TimeDiff for UI;
								declare netwrite Integer Net_TimeDiffCT for UI;
								Net_TimeDiff = -1*(BestCPTimes[RoundCP]-(E.LapTime));
								Net_TimeDiffCT = Now;
							}
							
							if (E.IsEndLap) {
								if (BestTime > E.Player.CurLap.Time || BestTime == -1) {
									BestTime = E.Player.CurLap.Time;
									foreach (LapCP => LapTime in E.Player.CurLap.Checkpoints) {
										BestCPTimes[LapCP] = LapTime;
									}
								}
							} else if (BestTime == -1) { // If not finished, save fastest CPs
								if (BestCPTimes.existskey(RoundCP)) {
									if (BestCPTimes[RoundCP] > E.Player.CurLap.Time) {
										BestCPTimes[RoundCP] = E.Player.CurLap.Time;
									}
								} else {
									BestCPTimes[RoundCP] = E.Player.CurLap.Time;
								}
							}
						} default:
							PassOn(E);
					}
				}
				foreach (E in XmlRpc.PendingEvents) {
					if (E.Type != CXmlRpcEvent::EType::Callback)
						continue;
					switch (E.Param1) {
						case "Endurance.CtSet.WarmingUp": {
							CtWarmingUp = E.Param2;
						}
						case "Endurance.CtSet.RankPanelType": {
							CtRankPanelType = TextLib::ToInteger(E.Param2);
							if (CtRankPanelType < 0 || CtRankPanelType > 1)
								CtRankPanelType = 0;
						}
						case "Endurance.CtSet.HideWarmingUpStatus": {
							CtHideWarmingUpStatus = (E.Param2 == "True" || E.Param2 == "true" || E.Param2 == "1");
						}
						case "Endurance.CtSet.PermitStarting": {
							CtPermitStarting = (E.Param2 == "True" || E.Param2 == "true" || E.Param2 == "1");
						}
						case "Endurance.ThrowMessageAll": {
							ThrowMsgAll(E.Param2, False);
						}
					}
				}
				if (MatchEndRequested) {
					break;
				}

				declare Text[] Racers;
				foreach (Player in PlayersRacing)
					Racers.add(Player.User.Login);
				foreach (Player in AllPlayers) {
					declare UI <=> UIManager.GetUI(Player);
					if (UI == Null) continue;
					if (UI.UILayers.count != 1) { // add local GUI layer if not there
						UI.UILayers.clear();
						declare LayerGui <=> UIManager.UILayerCreate();
						LayerGui.Type = CUILayer::EUILayerType::Normal;
						UI.UILayers.add(LayerGui);
						LayerGui.ManialinkPage = MLGet_Gui(CtRankPanelType);
					}
					UI.ForceSpectator = Player.RaceStartTime == 0;
					declare netwrite Text[] Net_Racers for UI;
					Net_Racers = Racers;
					declare netwrite Text Net_Leader for UI;
					Net_Leader = Leader;
					declare netwrite Text Net_LeaderNickName for UI;
					Net_LeaderNickName = LeaderNickName;
					declare netwrite Integer Net_ReachCP for UI;
					declare netwrite Integer[Integer] Net_ReachTimes for UI;
					declare netwrite Integer Net_DriversLeft for UI;
					declare netwrite Integer Net_DriversTotal for UI;
					Net_ReachCP = ReachCP;
					Net_ReachTimes = ReachTimes;
					Net_DriversLeft = Racers.count;
					Net_DriversTotal = Players.count;
				}
				foreach (Player in PlayersRacing) {
					declare UI <=> UIManager.GetUI(Player);
					if (UI == Null) continue;
					declare netwrite Integer[Integer] Net_ReachTimes for UI;
					declare Integer CP for Player;
					if (Net_ReachTimes.existskey(CP+1) && Player.RaceStartTime != 0)
						if (Net_ReachTimes[CP+1]-Now <= 0) {
							if (PlayersRacing.count == 2) {
								EndLatestKO = Player.User.Login;
								Scores_Sort(CTmMode::ETmScoreSortOrder::TotalPoints);
							}
							Player.RaceStartTime = 0;
							ThrowMsgAll(Player.User.Name^"$z$2c2$s got eliminated!", False);
							declare netwrite Integer Net_KnockOut for UI;
							Net_KnockOut = Now;
						}
				}
				if (((PlayersRacing.count == 2 && EndLatestKO != "") || PlayersRacing.count == 1) && EndOnVictory == 1) {
					if (PlayersRacing.existskey(0))
						PlayersRacing[0].RaceStartTime = 0;
					if (PlayersRacing.existskey(1))
						PlayersRacing[1].RaceStartTime = 0;
					
					declare Player <=> PlayersRacing[0];
					if (Player.User.Login == EndLatestKO && PlayersRacing.count == 2) Player <=> PlayersRacing[1];
					if (Player != Null) {
						declare UI <=> UIManager.GetUI(Player);
						if (UI != Null) {
							Scores_Sort(CTmMode::ETmScoreSortOrder::TotalPoints);
							EndWinner = Player.User.Login;
							ThrowMsgAll(Player.User.Name^"$z$2c2$s wins this round!", True);
							winner = True;
							break;
						}
					}
				} else if (PlayersRacing.count == 0) { // if somehow all players quit not triggering the MatchEnd
					break;
				}

				if (LastUIUpdateTime + C_UITickPeriod < Now) {
					Scores_Sort(CTmMode::ETmScoreSortOrder::TotalPoints);
					LastUIUpdateTime = Now;

					declare UsedLayers = Ident[];

					foreach (Player in AllPlayers) {
						if (!Players.exists(Player))
							Player.Score.Points = 0;
						declare UI <=> UIManager.GetUI(Player);
						if (UI == Null) continue;

						declare CUILayer LayerLocal;
						if (UI.UILayers.count != 1) {
							UI.UILayers.clear();
							LayerLocal <=> UIManager.UILayerCreate();
							LayerLocal.Type = CUILayer::EUILayerType::Normal;
							UI.UILayers.add(LayerLocal);
						} else {
							LayerLocal <=> UI.UILayers[0];
						}
						UsedLayers.add(LayerLocal.Id);

						if (Player.RaceStartTime == 0) {
							declare netread Net_SpecTargetReq for UI = "";
							if (Net_SpecTargetReq == "") continue;
							foreach (Racer in PlayersRacing) {
								if (Racer.User.Login == Net_SpecTargetReq) {
									declare UI2 <=> UIManager.GetUI(Racer);
									if (UI2 == Null) continue;
									declare netwrite Integer Net_CP as Net_CP1 for UI;
									declare netwrite Integer Net_CP as Net_CP2 for UI2;
									Net_CP1 = Net_CP2;
									declare netwrite Integer Net_Position as Net_Position1 for UI;
									declare netwrite Integer Net_Position as Net_Position2 for UI2;
									Net_Position1 = Net_Position2;
									declare netwrite Integer Net_AfterCPTimeLeft as Net_AfterCPTimeLeft1 for UI;
									declare netwrite Integer Net_AfterCPTimeLeft as Net_AfterCPTimeLeft2 for UI2;
									Net_AfterCPTimeLeft1 = Net_AfterCPTimeLeft2;
								}
							}
						}
					}
					declare LayersToRemove = Ident[];
					foreach (Layer in UIManager.UIAll.UILayers) { UsedLayers.add(Layer.Id); }
					UsedLayers.add(LayerScoresTable.Id);
					foreach (Layer in UIManager.UILayers) {
						if (!UsedLayers.exists(Layer.Id)) {
							LayersToRemove.add(Layer.Id);
						}
					}
					foreach (LayerId in LayersToRemove) { // Removing layers that are not being used!
						UIManager.UILayerDestroy(UIManager.UILayers[LayerId]);
					}
				}
			}
			UIManager.UIAll.StatusMessage = "";
			UIManager.UIAll.CountdownEndTime = 0;
			foreach (Player in AllPlayers) {
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				if (UI.UILayers.count == 1) {
					declare CUILayer LayerLocal;
					LayerLocal <=> UI.UILayers[0];
					LayerLocal.ManialinkPage = "";
				}
			}
			Scores_Sort(CTmMode::ETmScoreSortOrder::TotalPoints);
		}
		foreach (Player in AllPlayers)
			Player.RaceStartTime = 0;
		UIManager.UIAll.BigMessage = "";
		UIManager.UIAll.StatusMessage = "";
		if (winner) {
			declare Text Output = "";
			foreach (Score in Scores) {
				if (Score.Points != 0) {
					Output ^= Score.User.Login^":"^Score.Points^",";
				}
			}
			enduro_scores = Output;
			XmlRpc.SendCallback_EndRound();

			UIManager.UIAll.ScoreTableOnlyManialink = True;
			UIManager.UIAll.OverlayHideRoundScores = True;
			Ladder_ComputeRank(CTmMode::ETmScoreSortOrder::TotalPoints);
			Ladder_CloseMatchRequest();
			LayerScoresTable.ManialinkPage = MLGet_ScoreTable(True);
			if (last_round == False) {
				UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
				UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
				declare Integer RoundEndWaitTime = Now+RoundEndWait;
				WaitPass(RoundEndWaitTime);
				continue; // Start new round
			} else {
				CutOffTimeLimit = Now+MatchEndWait;
				UIManager.UIAll.CountdownEndTime = CutOffTimeLimit;
				UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
				WaitPass(CutOffTimeLimit);
			}
		}

		UIManager.UIAll.UILayers.clear();	
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;	
		UIManager.UIAll.StatusMessage = "Please wait...";
		foreach (Player in AllPlayers) {
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			UI.UISequence = CUIConfig::EUISequence::None;	
		}

		RequestUnloadMap();
		wait(!MapLoaded);
	}
	UIManager.UILayerDestroy(LayerScoresTable);
}