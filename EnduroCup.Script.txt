/*
Endurance Gamemode for TrackMania 2
Copyright (C) 2013 TGYoshi/Tiggs
Modified to EnduroCup by Virtex (fsxelw) (05-2017)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
Please see <http://dl.dropbox.com/u/7795439/tm2/web_Endurance/index.html>[1] for updates and support using this gamemode.
If you want to submit an improvement to the gamemode, please contact me (see [1]).
*/
/*
For to-do list, see <http://dl.dropbox.com/u/7795439/tm2/web_Endurance/index.html>.
*/

#RequireContext CTmMode
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/TrackMania/TM3.Script.txt" as TM
#Include "Libs/Nadeo/TrackMania/WarmUp.Script.txt" as WarmUp
#Include "Libs/Nadeo/ModeInfo.Script.txt" as ModeInfo
#Const	Version				"V3.0-test-cup V1.4b-alpha"

//// GENERIC SETTINGS ////
#Const PlayersReq 				2		// PLAYERS REQUIRED BEFORE THE GAME STARTS (Generally >= 2)
#Const WarmupTime 				10000	// WARMING UP TIME IN MS (1000 = 1 second)
#Const TimeMargeP1				30000   // START TIME MARGE
#Const TimeMargeP2				0.95    // DEFAULT MULTIPLICATION PER CP (Generally <= 1.0)
#Const RoundEndWait				5000	// WAITING TIME AT ROUNDEND in MS (1000 = 1 second)
#Const MatchEndWait				20000	// WAITING TIME AT MATCHEND in MS (1000 = 1 second)
#Const SkipIntro				1		// SKIP INTRO? (0 = no, 1 = yes)

//// DEBUG SETTINGS ////
#Const EndOnVictory				1		// Set to 0 to prevent the match from ending (debug). (default 1)

//// MODE CONSTANTS ////
#Const Description				_("""$fffTest""")
#Const StatusMessage			_("TYPE: Free for all\nOBJECTIVE: Don't get eliminated by the timer.")
#Const C_UITickPeriod			200
#Const UnfollowSpawnSyncTime	3000
#Const DfWarmingUp				"$fb2Warming up"


Text GetTime(Integer StartTime) {
	declare Text r = TextLib::TimeToText(Now-StartTime);
	declare Text b = TextLib::ToText(Now-StartTime);
	r ^= "."^TextLib::SubString(b, TextLib::Length(b)-3, 3);
	return r;
}
Text GetTime2(Integer RealTime) {
	declare Text r = TextLib::TimeToText(RealTime);
	declare Text b = TextLib::ToText(RealTime+10000);
	r ^= "."^TextLib::SubString(b, TextLib::Length(b)-3, 3);
	return r;
}
Text GetLegitBoolText(Boolean what) {
	if (what)
		return "true";
	return "false";
}

declare Text EndLatestKO;
declare Text EndWinner;

Text MLGet_ScoreTable(Boolean ShowLP) {
	declare ML = """
	<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
	<manialink version="3" name="ScoresTable">
		<stylesheet>
			<style class="text-default" textfont="Oswald" textcolor="fff" textemboss="1"/>
			<style class="text-number" textfont="OswaldMono" textcolor="fff" textemboss="1"/>
		</stylesheet>
		<frame pos="0 70.5" z-index="0" scale="1">
			<framemodel id="framemodelcolumnheader">
				<quad size="68.1 0.8" valign="bottom" colorize="1ec8c2" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderSmall.dds" />
				<quad pos="68 0" size="26.8 0.8" valign="bottom" colorize="1ec8c2" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderBig.dds" />
			</framemodel>
			<framemodel id="framemodelscorecard">
				<frame z-index="-100" >
					<quad pos="16 -6.23" size="10 0.8" rot="90" halign="center" valign="center" opacity="0.1" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderSmall.dds" />
					<quad pos="3.70 -6.23" z-index="-1" size="95 12" valign="center" opacity="0.5" colorize="0b081b" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/Colorize.dds" />
					<quad pos="3 -6.23" z-index="-2" size="96.5 13" valign="center" opacity="0.8" id="scorecard_quadbackgroundblink"	style="Icons128x128_Blink" substyle="ShareBlink"	hidden="1"/>
					<quad pos="3.70 -6.23" z-index="-3" size="95 12" valign="center" style="Bgs1" substyle="BgDialogBlur" opacity="0.35" />
				</frame>
				<label pos="9.93 -6.23" size="12.45 12.45" scale="0.80" halign="center" valign="center2" textsize="7" text="0" class="text-number" id="scorecard_localrank"/>
				<frame pos="16.15 -8.9">
					<quad pos="1.97 -1.68" size="3.36 3.36" scale="0.9" halign="left" valign="center" style="Icons64x64_1" substyle="LvlGreen" id="scorecard_quadstatus"/>
					<label pos="5.71 -1.68" size="41.27 3.36" valign="center2" textsize="1" textcolor="aeacb0" textprefix="$t> " text="WORLD: NOT RANKED" class="text-default" id="scorecard_labelmultirank"/>
					<frame id="framelpgain" hidden="1">
						<quad pos="52.32 -1.68" size="3.36 3.36" scale="1.5" valign="center" style="Icons128x128_1" substyle="LadderPoints"/>
						<label pos="51.70 -1.68" size="33.02 3.36" halign="right" valign="center2" textcolor="bb8" textsize="1.5" text="+0.0" class="text-number" id="scorecard_labellpgain"/>
					</frame>
					<frame id="frameendurostatus" hidden="0">
						<quad pos="77.27 -0.3" size="4 4" halign="left" valign="center" style="Icons128x128_1" substyle="Easy" id="scorecard_quadendurostatus"/>
					</frame>
					<frame id="framepointsgain" hidden="1">
						<label pos="75.57 -0.5" size="33.02 3.36" halign="left" valign="center2" textcolor="0F0" textsize="1.5" text="+250" class="text-number" id="scorecard_labelpointsgain"/>
					</frame>
				</frame>
				<frame z-index="1">
					<label pos="97.40 -4.67" size="16.92 12.45" halign="right" valign="center2" text="CP: 0" textsize="2.00" class="text-number" id="columns_labeltmpoints" z-index="-1"/>
					<quad pos="77.23 -2.98" size="3.90 3.90" halign="center" valign="center" scale="1.3" style="UIConstructionSimple_Buttons" substyle="Camera" scriptevents="1" id="columns_quadspec"/>
					<quad pos="77.23 -7.11" size="3.90 3.90" halign="center" valign="center" scale="1.3" style="UIConstructionSimple_Buttons" substyle="Author" scriptevents="1" id="columns_quadprofile"/>
					<quad pos="70.069 -5.970" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar0"/>
					<quad pos="72.672 -3.367" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar1"/>
					<quad pos="72.672 -5.970" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar2"/>
					<quad pos="70.069 -3.367" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar3"/>
					<quad pos="71.371 -4.669" size="2.603 2.603" halign="center" valign="center" style="BgRaceScore2" substyle="Fame" id="columns_quadmaniastar4"/>
					<label pos="25.82 -4.67" size="38.53 12.45" halign="left" valign="center2" text="long player name (to check the overflow)" textsize="2.00" class="text-default" id="columns_labelname"/>
					<quad pos="20.62 -4.67" size="7.81 7.81" image="file://Avatars/fsxelw/Default" halign="center" valign="center" id="columns_quadavatar"/>
				</frame>
			</framemodel>
			<quad pos="-0.531 -71.1" z-index="-100" size="322 182" halign="center"	valign="center" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/Dimmer.dds" />
			<quad z-index="-50" size="248.00 166.00" image="file://Media/Manialinks/Trackmania/ScoresTable/bg-canyon.dds" halign="center" hidden="1" id="quadbackground" />
			<frame pos="0 -26" id="frameheader">
				<label pos="-91 -9" z-index="1" size="88 10" text="SCORE" class="text-default" halign="left" valign="center2" textsize="8"/>
				<label pos="-91 -17" size="88 7" textsize="4.5" z-index="3" halign="left" valign="center2" text="RANKING" class="text-default" id="header_title"/>
				<label pos="97.5 -17+" size="94 10" text="$fffEnduroCup" halign="right" textsize="6" id="additionnalinfo_servername"	valign="center2" class="text-default"/>
				<quad pos="-94.5 -11.5" z-index="-1" size="1.4 16.5" halign="right" valign="center" bgcolor="fff" />
				<quad pos="41.66 -11.21" size="7.47 7.47" image="" halign="right" valign="center"/>
			</frame>
			<frame id="framefooter" pos="0 -160.50">
				<frame z-index="0">
					<quad z-index="0" size="94 24" halign="center" valign="bottom" style="Bgs1" substyle="BgDialogBlur" opacity="0.35"	pos="0 0"/>
					<quad z-index="1" size="94 24" halign="center" valign="bottom" bgcolor="0b081b" opacity="0.98" />
					<quad pos="-47 24" z-index="2" size="3 3" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderCorner.dds" />
					<quad pos="-46 24" z-index="2" size="93 0.8" rot="180" halign="right" valign="bottom" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderSmall.dds" />
				</frame>
				<frame id="frameplayerinfo" pos="-45 12" z-index="1">
					<quad size="16 16" image="file://Avatars/fsxelw/Default" valign="center" id="playerinfo_avatar" />
					<label pos="17 0" size="10 10" valign="center2" textsize="6" text="#1" class="text-number" id="playerinfo_rank" />
				</frame>
				<frame id="framepager" pos="0 5" z-index="3">
					<quad pos="-12.5 7.7" halign="center" valign="center"	size="12 12" scriptevents="1" id="pager_buttonprev" style="UIConstruction_Buttons" substyle="Quit"/>
					<quad pos="12.5 7.7" rot="180" halign="center" valign="center" size="12 12"	style="UIConstruction_Buttons" substyle="Quit" scriptevents="1" id="pager_buttonnext"/>
					<label pos="0 8" size="10 10" z-index="2" halign="center" valign="center2" text="1" id="pager_number" textsize="5"/>
					<quad pos="-15 0.8" size="30 0.6" valign="bottom" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderSmall.dds" />
					<quad pos="15 0.8" size="2 0.6" halign="right" valign="bottom" colorize="fff" image="file://Media/Manialinks/Nadeo/Common/ScoresTable/HeaderBig.dds" />
				</frame>
				<frame z-index="20" pos="30 5">
					<label pos="0 8" size="10 10" z-index="2" halign="center" valign="center2" text="🔎" scriptevents="1" id="pager_findplayer"	focusareacolor1="0000" focusareacolor2="0000" textsize="5"/>
				</frame>
			</frame>
			<frame id="frametable" pos="0 -49">
				<frameinstance id="framecolumnheader#1" modelid="framemodelcolumnheader" pos="-95.9 1.4" z-index="-1" />
				<frameinstance id="framelegends#1" modelid="framemodellegends" pos="-99.70"/>
				<frameinstance id="scorecard#0" modelid="framemodelscorecard" pos="-99.70 -0.00" />
				<frameinstance id="scorecard#1" modelid="framemodelscorecard" pos="-99.70 -12.45" />
				<frameinstance id="scorecard#2" modelid="framemodelscorecard" pos="-99.70 -24.90" />
				<frameinstance id="scorecard#3" modelid="framemodelscorecard" pos="-99.70 -37.35" />
				<frameinstance id="scorecard#4" modelid="framemodelscorecard" pos="-99.70 -49.80" />
				<frameinstance id="scorecard#5" modelid="framemodelscorecard" pos="-99.70 -62.25" />
				<frameinstance id="framecolumnheader#2" modelid="framemodelcolumnheader" pos="3.1 1.4" z-index="-1" />
				<frameinstance id="framelegends#2" modelid="framemodellegends" pos="-0.50"/>
				<frameinstance id="scorecard#6" modelid="framemodelscorecard" pos="-0.50 -0.00" />
				<frameinstance id="scorecard#7" modelid="framemodelscorecard" pos="-0.50 -12.45" />
				<frameinstance id="scorecard#8" modelid="framemodelscorecard" pos="-0.50 -24.90" />
				<frameinstance id="scorecard#9" modelid="framemodelscorecard" pos="-0.50 -37.35" />
				<frameinstance id="scorecard#10" modelid="framemodelscorecard" pos="-0.50 -49.80" />
				<frameinstance id="scorecard#11" modelid="framemodelscorecard" pos="-0.50 -62.25" />
			</frame>
		</frame>
		<script><!--
			#Include "TextLib" as TextLib
			main () {
				declare netwrite Net_SpecTargetReq for UI = "";
				declare netwrite Integer Net_SpecTargetCn for UI = 0;
				declare Text PlayerSpec = "";
				declare netread Integer Net_Position for UI;
				declare Boolean[Text] SpectateStates;
				declare netread Text Net_SpecSuggest for UI;
				declare netread Integer Net_SpecSuggestTime for UI;
				declare Integer SpecSuggestTime;
				declare netread Integer Net_StartTime for UI;
				declare Integer LatestSpecUpdate = 0;

				declare CMlQuad quadPlayerAvatar <=> (Page.GetFirstChild("playerinfo_avatar") as CMlQuad);
				if (InputPlayer != Null) quadPlayerAvatar.ImageUrl = "file://Avatars/"^InputPlayer.User.Login^"/Default";
				while(True) {
					foreach(Event in PendingEvents)	{
						switch(Event.Type) {
							case CMlEvent::Type::MouseClick: {
								if (Event.ControlId == "columns_quadspec") {
									declare TargetSpec for Event.Control = InputPlayer.User.Login;
									if (TargetSpec == "")
										continue;
									SetSpectateTarget(TargetSpec);
									Net_SpecTargetReq = TargetSpec;
									Net_SpecTargetCn = Now;
								} else if (Event.ControlId == "columns_quadprofile") {
									declare TargetProfile for Event.Control = InputPlayer.User.Login;
									if (TargetProfile == "")
										continue;
									ShowProfile(TargetProfile);
								}
							}
						}
					}

					declare CMlLabel lblPlayerRank <=> (Page.GetFirstChild("playerinfo_rank") as CMlLabel);
					lblPlayerRank.Value = "#"^Net_Position; // Laat scoreboard pos zien bij end round!

					for(i, 0, 11) {
						declare CMlFrame frmScoreboard <=> (Page.GetFirstChild("scorecard#"^i) as CMlFrame);
						if (Scores.existskey(i)) {
							frmScoreboard.Show();

							// Constant
							declare CMlLabel lblName <=> (frmScoreboard.GetFirstChild("columns_labelname") as CMlLabel);
							if (lblName.Value != Scores[i].User.Name) {
								declare CMlQuad quadAvatar <=> (frmScoreboard.GetFirstChild("columns_quadavatar") as CMlQuad);
								declare CMlLabel lblRank <=> (frmScoreboard.GetFirstChild("scorecard_localrank") as CMlLabel);
								declare CMlLabel lblMultiRank <=> (frmScoreboard.GetFirstChild("scorecard_labelmultirank") as CMlLabel);
								declare CMlQuad quadSpec <=> (frmScoreboard.GetFirstChild("columns_quadspec") as CMlQuad);
								declare CMlQuad quadProfile <=> (frmScoreboard.GetFirstChild("columns_quadprofile") as CMlQuad);
								lblName.Value = Scores[i].User.Name;
								quadAvatar.ImageUrl = "file://Avatars/"^Scores[i].User.Login^"/Default";
								lblRank.Value = TextLib::ToText(i+1);
								declare Zone = _("Other");
								declare ZoneArray = TextLib::Split("|", Scores[i].User.LadderZoneName);
								if (ZoneArray.existskey(2)) Zone = ZoneArray[2];
								if (Scores[i].User.LadderRank > 0) lblMultiRank.Value = TextLib::Compose("%1: %2", Zone, TextLib::ToText(Scores[i].User.LadderRank));
								else lblMultiRank.Value = TextLib::Compose("%1: %2", Zone, _("Not ranked"));
								declare TargetSpec for quadSpec = Scores[i].User.Login;
								declare TargetProfile for quadProfile = Scores[i].User.Login;
								TargetSpec = Scores[i].User.Login;
								TargetProfile = Scores[i].User.Login;

								for(j, 0, 4) {
									declare CMlQuad quadStar <=> (frmScoreboard.GetFirstChild("columns_quadmaniastar"^j) as CMlQuad);
									if (Scores[i].User.FameStars > j) {
										quadStar.Show();
									} else {
										quadStar.Hide();
									}
								}
							}

							// Variable
							declare CMlLabel lblScore <=> (frmScoreboard.GetFirstChild("columns_labeltmpoints") as CMlLabel);
							lblScore.Value = "CP: "^(Scores[i].Points/1000);
						} else {
							frmScoreboard.Hide();
						}
					}

					if (GUIPlayer != Null && (IsSpectatorMode) && LatestSpecUpdate + 1000 < Now) {
						LatestSpecUpdate = Now;
						if (PlayerSpec != GUIPlayer.Login) {
							PlayerSpec = GUIPlayer.Login;
							Net_SpecTargetReq = GUIPlayer.Login;
							Net_SpecTargetCn = Now;
						}
					}
					yield;
				}
			}
		--></script>
	</manialink>
	""";
		return ML;
}

Text MLGet_Gui(Integer RankPanelType) {
	declare Text ML;
	ML = """
		<script><!--
			#Include "TextLib" as TextLib
			Text GetTime2(Integer RealTime) {
				declare Text r = TextLib::TimeToText(RealTime);
				declare Text b = TextLib::ToText(RealTime+10000);
				r ^= "."^TextLib::SubString(b, TextLib::Length(b)-3, 3);
				return r;
			}
			main () {
				declare CMlFrame FrameTimer <=> (Page.GetFirstChild("FrameTimer") as CMlFrame);
				declare CMlFrame PlayingButton <=> (Page.GetFirstChild("PlayingButton") as CMlFrame);
				declare CMlLabel LText <=> (Page.GetFirstChild("LText") as CMlLabel);
				declare CMlLabel LTime <=> (Page.GetFirstChild("LTime") as CMlLabel);
				declare CMlLabel Position <=> (Page.GetFirstChild("Position") as CMlLabel);
				declare CMlLabel TimeDiff <=> (Page.GetFirstChild("TimeDiff") as CMlLabel);
				
				declare LocalCP = 0;
				declare netread Integer Net_State for UI;
				declare netread Text Net_Leader for UI;
				declare netread Text Net_LeaderNickName for UI;
				declare CMlFrame PFrameLeader <=> (Page.GetFirstChild("Player_Leader") as CMlFrame);
				declare CMlLabel LPlayer_Leader <=> (Page.GetFirstChild("LPlayer_Leader") as CMlLabel);
				declare CMlFrame PFrameMain <=> (Page.GetFirstChild("Player_Main") as CMlFrame);
				declare CMlLabel LPlayer_Main <=> (Page.GetFirstChild("LPlayer_Main") as CMlLabel);
				
				// declare netread Integer[Text] Net_PlayerDistances for UI;
				declare netread Integer Net_CP for UI;
				declare Integer CP for UI;
				declare netread Integer Net_ReachCP for UI;
				declare netread Integer[Integer] Net_ReachTimes for UI;
				declare netread Integer Net_DriversLeft for UI;
				declare netread Integer Net_DriversTotal for UI;
				declare UIU = Now;
				declare UiMovementLeft = 0;
				declare Offset = 0;
				""";
				if (RankPanelType == 1)
					ML ^= """
				// declare CMlLabel LAbove <=> (Page.GetFirstChild("LAbove") as CMlLabel);
				// declare CMlLabel LUnder <=> (Page.GetFirstChild("LUnder") as CMlLabel);
				declare CMlLabel LDriversLeft <=> (Page.GetFirstChild("LDriversLeft") as CMlLabel);
				""";
				ML^= """
				
				declare CMlLabel End_Victory <=> (Page.GetFirstChild("End_Victory") as CMlLabel);
				declare CMlLabel End_Knockout <=> (Page.GetFirstChild("End_Knockout") as CMlLabel);
				declare CMlQuad ReadyIcon <=> (Page.GetFirstChild("_ReadyIcon") as CMlQuad);
				
				declare netread Integer Net_Victory for UI;
				declare netread Integer Net_KnockOut for UI;
				
				declare netread Integer Net_StartTime for UI;
				declare netread Integer Net_Position for UI;
				
				declare netread Integer Net_TimeDiff for UI;
				declare netread Integer Net_TimeDiffCT for UI;
				
				declare netread Integer Net_AfterCPTimeLeft for UI;
				declare Integer AfterCPTimeLeft;
				declare Integer AfterCPTimeLeftCT;
				declare Integer LastUpdateTime = 0;
				declare netread Text[Integer] Net_MsgText for UI;
				declare Text[] PrevMsgText;
				declare netread Integer[Integer] Net_MsgTextTime for UI;
				declare Integer PrevMsgTextTime = 0;
				declare Integer Ignore = 0;
				declare CMlLabel[Integer] statusls;
				for (i, 0, 4) {
					declare bit <=> (Page.GetFirstChild("Status"^i) as CMlLabel);
					statusls[i] = bit;
					//statusts[i] = 0;
				}
				declare Integer animation;
				while(True) {
					if (UIU + 100 < Now) {
						if ((IsSpectatorMode || Net_State == 0) && InputPlayer != Null) {
							PlayingButton.Show();
							if (!InputPlayer.RequestsSpectate)
								ReadyIcon.Substyle = "LvlGreen";
							else
								ReadyIcon.Substyle = "LvlRed";
						} else {
							PlayingButton.Hide();
						}
						Position.SetText("$08f"^Net_Position);
						/*if (GameTime-Net_Victory < 4000 && GameTime-Net_Victory > 0) {
							End_Victory.PosnY -= (End_Victory.PosnY-60*1.)/10.;
							End_Victory.Scale = 1.;
						} else if (End_Victory.Scale != 0) { 
							End_Victory.Scale -= 0.1;
							End_Victory.PosnY = 110.;
						}
						if (GameTime-Net_KnockOut < 4000 && GameTime-Net_KnockOut > 0) {
							End_Knockout.PosnY -= (End_Knockout.PosnY-60*1.)/10.;
							End_Knockout.Scale = 1.;
						} else if (End_Victory.Scale != 0) { 
							End_Knockout.Scale -= 0.1;
							End_Knockout.PosnY = 110.;
						}*/
						""";
						if (RankPanelType == 1)
							ML ^= """
						// declare Above = 0;
						// declare Under = 0;
						if (GUIPlayer != Null) {
							LPlayer_Main.SetText("$s"^GUIPlayer.Name);
							declare YPos = ((CP*20+9)+Offset-UiMovementLeft*2);
							PFrameMain.PosnY -= (PFrameMain.PosnY-(YPos)*1.)/10.;
							if (PFrameMain.PosnY >= 30) {
								// Above += 1;
								PFrameMain.Hide();
							} else if (PFrameMain.PosnY <= -30) {
								// Under += 1;
								PFrameMain.Hide();
							} else
								PFrameMain.Show();
							if (Net_Leader != "" && Net_Leader != GUIPlayer.Login) {
								LPlayer_Leader.SetText("$s"^Net_LeaderNickName);
								declare YPos = ((Net_ReachCP*20+9)+Offset-UiMovementLeft*2);
								PFrameLeader.PosnY -= (PFrameLeader.PosnY-(YPos)*1.)/10.;
								if (PFrameLeader.PosnY >= 30) {
									// Above += 1;
									PFrameLeader.Hide();
								} else if (PFrameLeader.PosnY <= -30) {
									// Under += 1;
									PFrameLeader.Hide();
								} else
									PFrameLeader.Show();
							} else {
								PFrameLeader.Hide();
							}
						}
						// LAbove.SetText("$s$o"^Above);
						// LUnder.SetText("$s$o"^Under);
						LDriversLeft.SetText("$383"^Net_DriversLeft^"$fff/$888"^Net_DriversTotal);
						if (UiMovementLeft != 0) {
							declare UiMovementDirection = 0;
							if (UiMovementLeft > 0) {
								UiMovementDirection = 1;
							} else {
								UiMovementDirection = UiMovementLeft; // Instant
							}
							UiMovementLeft -= UiMovementDirection;
							for (i, -1, 2) {
								declare CMlLabel L <=> (Page.GetFirstChild("CPL"^i) as CMlLabel);
								declare CMlQuad Q <=> (Page.GetFirstChild("CPQ"^i) as CMlQuad);
								L.PosnY -= UiMovementDirection;
								Q.PosnY -= UiMovementDirection;
								if (i == -1) {
									L.Hide();
									Q.Hide();
								}
							}
							Offset -= UiMovementDirection;
							if (UiMovementLeft == 0) {
								for (i, -1, 2) {
									declare CMlLabel L <=> (Page.GetFirstChild("CPL"^i) as CMlLabel);
									declare CMlQuad Q <=> (Page.GetFirstChild("CPQ"^i) as CMlQuad);
									L.PosnY = 20.*i-10.;
									Q.PosnY = 20.*i-10.;
									if (i == -1) {
										L.Show();
										Q.Show();
									}
									if (CP+i == 0)
										L.SetText("$000$sStart");
									else if (CP+i == -1)
										L.SetText("");
									else
										L.SetText("$000$sCP "^CP+i);
								}
							}
						}
						for (i, -1, 1) {
							declare CMlLabel L <=> (Page.GetFirstChild("CPCL"^i) as CMlLabel);
							declare CMlQuad Q <=> (Page.GetFirstChild("CPCQ"^i) as CMlQuad);
							if (Net_ReachTimes.existskey(CP+i+1)) {
								if ((Net_ReachTimes[CP+i+1]-GameTime) > 0) {
									L.SetText("$f00$s"^(Net_ReachTimes[CP+i+1]-GameTime)/1000^"");
								} else {
									L.SetText("$000$sXXX");
								}
								Q.Show();
							} else {
								L.SetText("");
								Q.Hide();
							}
						}""";
						ML^="""
					}
					if (Net_MsgTextTime.existskey(0) && Net_MsgTextTime[0] != PrevMsgTextTime) {
						//PrevMsgText = Net_MsgText;
						PrevMsgTextTime = Net_MsgTextTime[0];
						log("RECV "^Net_MsgTextTime[0]^" gt "^GameTime);
						//if (Now > Ignore+1000) {
						log("k");
						if (Net_MsgText.existskey(0)) {
							log("yy" ^ Net_MsgText[0]);
							statusls[4].SetText(Net_MsgText[4]);
							statusls[3].SetText(Net_MsgText[3]);
							statusls[2].SetText(Net_MsgText[2]);
							statusls[1].SetText(Net_MsgText[1]);
							statusls[0].SetText(Net_MsgText[0]);
							//statusts[4] = statusts[3]; // Can be improved
							//statusts[3] = statusts[2];
							//statusts[2] = statusts[1];
							//statusts[1] = statusts[0];
							//statusts[0] = Now;
							animation = Now;
							LastUpdateTime = 0;
						}
						//}
					}
					if (Net_MsgTextTime.existskey(0) && LastUpdateTime + 25 < Now) {
						declare Real animationTad = 4.;
						// Generic stud callover: (statusls[0].Scale/1.2)
						// Net_StreakScore_ => New streakscore
						// StreakFrom => Old streakscore
						// Net_StreakScore_ - StreakFrom => Difference, /2 => addition to StreakFrom
						if (Now <= animation+200)
							animationTad = (Now-animation)/50.;
						//	statusls[0].Scale = ((Now-animation)/500.)*0.8;
						//} else
						//	statusls[0].Scale = 1.2;
						for (i, 0, 4) {
							statusls[i].PosnY = -46.0+i*3.9+animationTad;
							if (GameTime > Net_MsgTextTime[i]+4500) {
								statusls[i].Scale = 0.;
								//log("bye " ^ Net_MsgTextTime[i] ^ "-"^GameTime);
							} else if (GameTime > Net_MsgTextTime[i]+4000) {
								statusls[i].Scale = 0.8-((GameTime-Net_MsgTextTime[i]-4000)/500.)*0.8;
							} else if (GameTime > Net_MsgTextTime[i]+500) {
								statusls[i].Scale = 0.8;
							} else {
								statusls[i].Scale = ((GameTime-Net_MsgTextTime[i])/500.)*0.8;
							}
						}
						
						LastUpdateTime = Now;
					}
					if (Net_CP != CP && UiMovementLeft == 0) {
						if (Net_CP > CP) {
							UiMovementLeft = 20;
							CP += 1;
						} else {
							UiMovementLeft = -20*(CP-Net_CP);
							CP = Net_CP;
						}
					}
					// important data, no delay
					if (!Net_ReachTimes.existskey(Net_CP+1)) { // || CP >= Net_ReachCP
						LText.SetText("$fff$sCheckpoint reached!");
						if (Net_AfterCPTimeLeft != AfterCPTimeLeft) {
							AfterCPTimeLeft = Net_AfterCPTimeLeft;
							AfterCPTimeLeftCT = Now;
						}
						if (AfterCPTimeLeftCT + 2000 < Now)
							FrameTimer.PosnY += (105-FrameTimer.PosnY)/20.;
						LTime.SetText("$f33"^GetTime2(Net_AfterCPTimeLeft));
						UI.UISequence = CUIConfig::EUISequence::None;
					} else if (Net_ReachTimes[Net_CP+1]-GameTime <= 0) {
						FrameTimer.PosnY += (90-FrameTimer.PosnY)/8.;
						LText.SetText("$s$fffReach $f00CP "^Net_CP+1^"$fff within...");
						LTime.SetText("$f330:00.000");
						UI.UISequence = CUIConfig::EUISequence::Outro;
					} else {
						FrameTimer.PosnY += (90-FrameTimer.PosnY)/8.;
						LText.SetText("$s$fffReach $f00CP "^Net_CP+1^"$fff within...");
						LTime.SetText("$f33"^GetTime2(Net_ReachTimes[Net_CP+1]-GameTime));
						UI.UISequence = CUIConfig::EUISequence::None;
					}
					if (Net_TimeDiffCT != 0 && Net_TimeDiffCT + 2000 > GameTime) {
						TimeDiff.Show();
						if (Net_TimeDiff < 0) {
							TimeDiff.SetText("$00f-"^GetTime2(Net_TimeDiff));
						} else {
							TimeDiff.SetText("$f00+"^GetTime2(Net_TimeDiff));
						}
					} else
						TimeDiff.Hide();
					if (IsSpectatorMode || Net_State == 0) {
						foreach(Event in PendingEvents)	{
							if (Event.Type == CMlEvent::Type::MouseClick) {
								if (Event.ControlId == "_Ready") {
									ShowInGameMenu();
								}
							}
						}
					}
					yield;
				}
			}
		--></script>""";
		if (RankPanelType == 1) {
		ML ^= """
		<frame posn="1 0 1" id="FrameRules">
			<label posn="0 -24 31" scale="1" halign="center" valign="center" text="" id="CName " Scale="0.8" />
			<!--Bar-->
			<quad sizen="2 62 0" posn="149 31 1" style="Bgs1" substyle="BgColorContour" />
			<!--<quad bgcolor="08fb" sizen="1 1" posn="150 32 1" valign="center" halign="center"/>
			<quad bgcolor="08f8" sizen="1 1" posn="150 33 1" valign="center" halign="center"/>
			<quad bgcolor="08f4" sizen="1 1" posn="150 34 1" valign="center" halign="center"/>-->
			<quad bgcolor="08f" sizen="1 60" posn="150 -1 1" valign="center" halign="center"/>
			
			<!--Inc CPs-->
			<!--<quad bgcolor="800" sizen="3 3" posn="150 30 2" valign="center" halign="center" id="CPQ2"/>-->
			<quad style="Icons128x32_1" substyle="RT_Rounds" sizen="6 6" posn="150 30 2" valign="center" halign="center" id="CPQ2"/>
			<label text="$000$sCP 2" style="TextPlayerCardScore" posn="147 30 3" valign="center" halign="right" scale="1" id="CPL2"/>
			
			<quad style="Icons128x32_1" substyle="RT_Rounds" sizen="6 6" posn="150 10 2" valign="center" halign="center" id="CPQ1"/>
			<label text="$000$sCP 1" style="TextPlayerCardScore" posn="147 10 3" valign="center" halign="right" scale="1" id="CPL1"/>
			<!--Prev CPs-->
			<!--Current CP-->
			<!--Prev CPs-->
			<quad style="Icons128x32_1" substyle="RT_Rounds" sizen="6 6" posn="150 -10 2" valign="center" halign="center" id="CPQ0"/>
			<label text="$000$sStart" style="TextPlayerCardScore" posn="147 -10 3" valign="center" halign="right" scale="1" id="CPL0"/>
			
			<quad style="Icons128x32_1" substyle="RT_Rounds" sizen="6 6" posn="150 -30 2" valign="center" halign="center" id="CPQ-1"/>
			<label text="" style="TextPlayerCardScore" posn="147 -30 3" valign="center" halign="right" scale="1" id="CPL-1"/>
			<!--Incoming CPs-->
			
			<!-- <label text="$s$o0" posn="150 -34 3" valign="center" halign="center" scale="0.7" id="LUnder"/> -->
			<!-- <quad posn="151 -30 3" sizen="8 8" style="UIConstruction_Buttons" substyle="Drive" /> -->
			<!-- <label text="$s$o0" posn="150 34 3" valign="center" halign="center" scale="0.7" id="LAbove"/> -->
			<!-- <quad posn="151 38 3" sizen="8 8" style="UIConstruction_Buttons" substyle="Drive" /> -->
			
			<!--CPStates-->
			
			<quad bgcolor="f77" sizen="1 18" posn="150 20 2" valign="center" halign="center" id="CPCQ1"/>
			<label text="$f00$s" style="TextPlayerCardScore" posn="151 20 3" valign="center" halign="left" scale="1.5" id="CPCL1"/>
			
			<quad bgcolor="f77" sizen="1 18" posn="150 0 2" valign="center" halign="center" id="CPCQ0"/>
			<label text="$f00$s" style="TextPlayerCardScore" posn="151 0 3" valign="center" halign="left" scale="1.5" id="CPCL0"/>
			
			<quad bgcolor="f77" sizen="1 18" posn="150 -20 2" valign="center" halign="center" id="CPCQ-1"/>
			<label text="$f00$s" style="TextPlayerCardScore" posn="151 -20 3" valign="center" halign="left" scale="1.5" id="CPCL-1"/>
			
			<label text="$s$i$08fDrivers left:" posn="153 -37 3" valign="center" halign="center" scale="0.45"/>
			<label style="TextValueSmallSm" text="$3830$fff/$8880" posn="153 -40 3" valign="center" halign="center" scale="1" id="LDriversLeft"/>
			
			<!--User Frames-->
			""";
			// foreach(Login => Nickname in PlayerData) {
				// declare Style = "LvlRed";
				// if (Login == ForLogin) Style = "LvlGreen";
				// ML^="""<frame posn="0 0 1" id="Player_{{{Login}}}">
				// <quad style="Icons64x64_1" substyle="{{{Style}}}" sizen="4 3" posn="150 -17 6" valign="center" halign="center"/>
				// <label text="$s{{{Nickname}}}" posn="148 -17 5" valign="center" halign="right" scale="0.5"/>
				// </frame>""";
			// }
			declare Style = "LvlRed";
			ML^="""<frame posn="0 0 1" id="Player_Leader">
			<quad style="Icons64x64_1" substyle="{{{Style}}}" sizen="4 3" posn="150 -17 6" valign="center" halign="center"/>
			<label posn="148 -17 5" valign="center" halign="right" scale="0.5" id="LPlayer_Leader"/>
			</frame>""";
			Style = "LvlGreen";
			ML^="""<frame posn="0 0 1" id="Player_Main">
			<quad style="Icons64x64_1" substyle="{{{Style}}}" sizen="4 3" posn="150 -17 6" valign="center" halign="center"/>
			<label posn="148 -17 5" valign="center" halign="right" scale="0.5" id="LPlayer_Main"/>
			</frame>""";
		ML^="""</frame>""";
		}
		ML^="""
		<frame posn="0 90 1" id="FrameTimer">
			<!--<quad sizen="66 15 1" posn="-33 0.1 0" style="UiSMSpectatorScoreBig" substyle="CenterShield" />--><!-- It's a little too appearant imo.. -->
			<!--<quad style="Bgs1InRace" substyle="BgHealthBar" sizen="50 6" posn="-25 -0.5 2"/>-->
			<label text="$s$o$fffReach $f00CP 0$fff within..." posn="0 -3 5" valign="center" halign="center" scale="0.3" id="LText" style="TextRaceMessageBig"/>
			<label text="$f000:00.000" posn="0 -8 5" valign="center" halign="center" style="TextRaceChrono" scale="0.8" id="LTime"/>
		</frame>
		<label text="$FB2$o$sVICTORY" scale="0" posn="0 110 10" valign="center" halign="center" textsize="10" id="End_Victory"/>
		<label text="$f33$o$sKNOCKED OUT" scale="0" posn="0 110 10" valign="center" halign="center" textsize="7" id="End_Knockout"/>
		
		<label text="$08f0" posn="153 -48 10" valign="center" halign="right" style="TextRaceChrono" textsize="10" id="Position"/>
		<label text="$00f+0:00.00" posn="0 27.5 10" sizen="16 0" valign="center" halign="center" style="TextRaceChrono" textsize="4" id="TimeDiff"/>
		<frame posn="0 -75 1" id="PlayingButton">
			<quad style="Icons64x64_1" substyle="LvlGreen" sizen="7 7" posn="-13 0 31" valign="center" id="_ReadyIcon" halign="center"/>
			<label text="    Playing" posn="0 0 30" valign="center" halign="center" style="CardButtonMedium" id="_Ready" scriptevents="1"/>
		</frame>
		""";
		ML ^= """
		<label valign="center" id="Status0" text="$s$o$fff" posn="-157 -34" scale="0.7" textemboss="true" />
		<label valign="center" id="Status1" text="$s$o$fff" posn="-157 -37" scale="0.7" textemboss="true" />
		<label valign="center" id="Status2" text="$s$o$fff" posn="-157 -40" scale="0.7" textemboss="true" />
		<label valign="center" id="Status3" text="$s$o$fff" posn="-157 -43" scale="0.7" textemboss="true" />
		<label valign="center" id="Status4" text="$s$o$fff" posn="-157 -46" scale="0.7" textemboss="true" />
	""";
		return ML;
}

// declare Integer[Text] PlayerDistances;
// Void SetDistance(Integer T, Text Name) {
	// declare Integer Target = T+9;
	// PlayerDistances[Name] = Target;
	// foreach (Player => Distance in PlayerDistances) {
		// if (Distance == Target && Player != Name) {
			// SetDistance(Distance-7, Player);
			// break;
		// }
	// }
// }

Void ThrowMsg(CUIConfig UI, Text Msg, Boolean Force) {
	declare netwrite Text[Integer] Net_MsgText for UI;
	declare netwrite Integer[Integer] Net_MsgTextTime for UI;
	//if (Force || Now-Net_MsgTextTime > 100) {
		if (!Net_MsgText.existskey(4)) {
			Net_MsgText[4] = "";Net_MsgText[3] = "";Net_MsgText[2] = "";Net_MsgText[1] = "";Net_MsgText[0] = "";
			Net_MsgTextTime[4] = 0;Net_MsgTextTime[3] = 0;Net_MsgTextTime[2] = 0;Net_MsgTextTime[1] = 0;Net_MsgTextTime[0] = 0;
		}
		Net_MsgText[4] = Net_MsgText[3];
		Net_MsgText[3] = Net_MsgText[2];
		Net_MsgText[2] = Net_MsgText[1];
		Net_MsgText[1] = Net_MsgText[0];
		Net_MsgText[0] = Msg;
		Net_MsgTextTime[4] = Net_MsgTextTime[3];
		Net_MsgTextTime[3] = Net_MsgTextTime[2];
		Net_MsgTextTime[2] = Net_MsgTextTime[1];
		Net_MsgTextTime[1] = Net_MsgTextTime[0];
		Net_MsgTextTime[0] = Now;
		// log("THROW MSG" ^ Net_MsgTextTime[0]);
	//}
}

Void ThrowMsgAll(Text Msg, Boolean Force) {
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		ThrowMsg(UI, Msg, Force);
	}
}

Void ResetAll() {
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare Integer CP for Player;
		CP = 0;
		declare Integer CP as CPScore for Player.Score;
		CPScore = CP;
		declare Integer Round for Player;
		Round = 0;
		declare netwrite Integer Net_CP for UI;
		Net_CP = CP;
		declare netwrite Integer Net_Victory for UI;
		Net_Victory = 0;
		declare netwrite Integer Net_KnockOut for UI;
		Net_KnockOut = 0;
		declare netwrite Integer Net_Position for UI;
		Net_Position = 1;
		Player.Score.Clear();
	}
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		
		UI.UILayers.clear();
		declare LayerGui <=> UIManager.UILayerCreate();
		LayerGui.Type = CUILayer::EUILayerType::Normal;
		UI.UILayers.add(LayerGui);
		
		// declare netwrite Integer[Text] Net_PlayerDistances for UI;
		// Net_PlayerDistances = PlayerDistances;
	}
}

Void WaitPass(Integer TimePass) {
	while (TimePass > Now) {
		foreach (E in PendingEvents) {
			switch (E.Type) {
				case CTmModeEvent::EType::GiveUp:
					Discard(E);
				case CTmModeEvent::EType::WayPoint: 
					Discard(E);
				default:
					PassOn(E);
			}
		}
		yield;
	}
}

Void Synchro() {
	declare Barrier = Synchro_AddBarrier();
	while (!Synchro_BarrierReached(Barrier) && !ServerShutdownRequested) yield;
}

main() {
	log("== Restart ==");
	log("Mode: EnduroCup");
	log("Version: "^Version);
	log("Original author: TGYoshi");
	log("Modified for cup by: Virtex");
	log("=============");

	ModeInfo::SetName("Enduro Cup");
	ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
	ModeInfo::SetRules(Description);
	ModeInfo::SetStatusMessage(StatusMessage);

	declare netwrite version for XmlRpc = Version;
	declare netwrite enduro_scores for XmlRpc = "";
	declare netread decreaser for XmlRpc = TimeMargeP2;
	declare netread Boolean last_round for XmlRpc = False;
	IndependantLaps = False;
	NbLaps = 0;
	//HideOpponents = False;
	//ForceMaxOpponents = 100;
	UiRounds = True;
	RespawnBehaviour = CTmMode::ETMRespawnBehaviour::Normal;

	declare LayerScoresTable	<=> UIManager.UILayerCreate();
	LayerScoresTable.Type = CUILayer::EUILayerType::ScoresTable;

	UIManager.UIAll.ScoreTableOnlyManialink = True;
	UIManager.UIAll.ScoreTable = "";
	UIManager.UIAll.SmallScoreTable = "";
	declare Integer ReachCP;
	declare Integer[Integer] ReachTimes;
	// declare Text[Text] PlayerData;
	declare Text[][Integer] PlayersReached;
	declare Text     CtWarmingUp = DfWarmingUp;
	declare Boolean  CtHideWarmingUpStatus = False;
	declare Integer  CtRankPanelType = 1;
	declare Boolean  CtPermitStarting = True;
	
	// XmlRpc.SendCallback("Endurance.Reset", """{}""");
	
	while (!ServerShutdownRequested) {
		log("== New Round ==");
		if (!MapLoaded)
			RequestLoadMap();
		wait(MapLoaded);
		foreach (Player in AllPlayers) {
			// Reset
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			UI.ForceSpectator = False;
		}
		UIManager.UIAll.StatusMessage = "Please wait...";
		sleep(UnfollowSpawnSyncTime); // Give time to client to unfollow other player before spawning in order to follow client player (MP bug)
		Scores_Clear();
		ResetAll();
		ReachCP = 0;
		ReachTimes.clear();
		// PlayerDistances.clear();
		// PlayerData.clear();
		
		declare MapWinnerId = NullId;
		MatchEndRequested = False;
		
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Intro;
		UIManager.UIAll.BigMessage = "";
		UIManager.UIAll.StatusMessage = "";
		if (SkipIntro != 1)
			wait(UIManager.UIAll.UISequenceIsCompleted);

		declare Integer EndTime;
		declare Integer StartTime;
		
		UIManager.ResetAll();
		UIManager.UIAll.ScoreTableOnlyManialink = True;
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
		UIManager.UIAll.UILayers.clear();
		UIManager.UIAll.UILayers.add(LayerScoresTable);
		LayerScoresTable.ManialinkPage = MLGet_ScoreTable(False);
		// XmlRpc.SendCallback("Endurance.MapLoaded", """{}""");
		UIManager.UIAll.StatusMessage = "Please wait...";
		UIManager.UIAll.BigMessage = CtWarmingUp;
		declare Integer StartingAt = 0;
		ReachTimes.clear();
		// XmlRpc.SendCallback("Endurance.MatchStarted", """{}""");
		XmlRpc.SendCallback_BeginRound();
		// XmlRpc.SendCallback("Endurance.WarmingUp", """{}""");
		WarmUp::Begin();
		declare Integer LatestUiUpdate = Now;
		while (!MatchEndRequested) {
			foreach (Player in AllPlayers) {
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				declare netwrite Integer Net_State for UI;
				Net_State = 0;
				UI.UISequence = CUIConfig::EUISequence::None;
				Player.Score.Points = 0;
				declare Integer CP for Player;
				CP = 0;
				declare Integer CP as CPScore for Player.Score;
				CPScore = CP;
				declare netwrite Integer Net_ReachCP for UI;
				Net_ReachCP = 0;
				declare netwrite Integer Net_Position for UI;
				Net_Position = 0;
				declare netwrite Integer Net_DriversLeft for UI;
				Net_DriversLeft = 0;
				declare netwrite Integer Net_DriversTotal for UI;
				Net_DriversTotal = 0;
				declare netwrite Integer[Integer] Net_ReachTimes for UI;
				Net_ReachTimes = ReachTimes;
				declare netwrite Integer Net_AfterCPTimeLeft for UI;
				Net_AfterCPTimeLeft = 0;
				
				if (UI.UILayers.count != 1) {
					UI.UILayers.clear();
					declare LayerGui <=> UIManager.UILayerCreate();
					LayerGui.Type = CUILayer::EUILayerType::Normal;
					UI.UILayers.add(LayerGui);
					LayerGui.ManialinkPage = MLGet_Gui(CtRankPanelType);
				}
			}
			foreach (Player in PlayersWaiting) {
				Player.RaceStartTime = Now+3000;
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				ThrowMsg(UI, "$2c2"^(WarmupTime/1000)^" seconds warming up", False);
			}
			if (CtHideWarmingUpStatus) {
				UIManager.UIAll.StatusMessage = "";
				if (!CtPermitStarting || Players.count < PlayersReq)
					StartingAt = 0;
				else if (StartingAt == 0)
					StartingAt = Now+WarmupTime;
			} else {
				if (!CtPermitStarting) {
					UIManager.UIAll.StatusMessage = "Match start prohibited.";
					StartingAt = 0;
				} else if (Players.count < PlayersReq) {
					UIManager.UIAll.StatusMessage = "At least "^PlayersReq^" players required to start. ("^PlayersRacing.count^"/"^PlayersReq^")";
					StartingAt = 0;
				} else {
					if (StartingAt == 0)
						StartingAt = Now+WarmupTime;
					UIManager.UIAll.StatusMessage = "Starting in "^(StartingAt-Now)/1000^" seconds...";
				}
			}
			foreach (E in XmlRpc.PendingEvents) {
				if (E.Type != CXmlRpcEvent::EType::Callback)
					continue;
				switch (E.Param1) {
					case "Endurance.StartMatch": {
						StartingAt = 1;
						break;
					}
					case "Endurance.CtSet.WarmingUp": {
						CtWarmingUp = E.Param2;
					}
					case "Endurance.CtSet.RankPanelType": {
						CtRankPanelType = TextLib::ToInteger(E.Param2);
						if (CtRankPanelType < 0 || CtRankPanelType > 1)
							CtRankPanelType = 0;
					}
					case "Endurance.CtSet.HideWarmingUpStatus": {
						CtHideWarmingUpStatus = (E.Param2 == "True" || E.Param2 == "true" || E.Param2 == "1");
					}
					case "Endurance.CtSet.PermitStarting": {
						CtPermitStarting = (E.Param2 == "True" || E.Param2 == "true" || E.Param2 == "1");
					}
					case "Endurance.ThrowMessageAll": {
						ThrowMsgAll(E.Param2, False);
					}
				}
			}
			CutOffTimeLimit = StartingAt;
			if ((StartingAt-Now) <= 0 && StartingAt != 0)
				break;
			UIManager.UIAll.BigMessage = CtWarmingUp;
			yield;
		}
		// XmlRpc.SendCallback("Endurance.WarmingUpEnded", """{}""");
		WarmUp::End();
		CutOffTimeLimit = 0;
		declare Boolean winner = False;
		UIManager.UIAll.BigMessage = "";
		UIManager.UIAll.StatusMessage = "Synchronization...";
		sleep(100);
		Synchro();
		
		if (!MatchEndRequested && !ServerShutdownRequested) {
			UIManager.UIAll.StatusMessage = "Starting...";
			foreach (Player in PlayersRacing) {
				Player.RaceStartTime = 0;
			}
			Ladder_CancelMatchRequest();
			wait(!Ladder_RequestInProgress); 
			
			Ladder_OpenMatch_BeginRequest(); 
			foreach(Score in Scores) { 
				Ladder_OpenMatch_AddPlayer(Score); 
			}
			Ladder_OpenMatch_EndRequest(); 
			wait(!Ladder_RequestInProgress); 

			ReachCP = 0;
			ReachTimes.clear();
			foreach (Player in AllPlayers) {
				// Reset
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				UI.ForceSpectator = False;
				declare netwrite Integer Net_State for UI;
				Net_State = 1;
			}

			sleep(UnfollowSpawnSyncTime); // Give time to client to unfollow other player before spawning in order to follow client player (MP bug)
			declare Integer MatchStartTime = Now;
			if (last_round == True)
				ThrowMsgAll("$z$w$s$F00LIVE! $z$s$2c2LAST ROUND has started, GLHF!", True);
			else
				ThrowMsgAll("$z$w$s$F00LIVE! $z$s$2c2Round has started, GLHF!", True);

			if (Now-StartTime > 3000) UIManager.UIAll.StatusMessage = "";
			// Match start
			UIManager.UIAll.CountdownEndTime = 0;
		
			StartTime = Now;

			declare RoundEndRequested = False;
			declare LastUIUpdateTime = -C_UITickPeriod;
			LayerScoresTable.ManialinkPage = MLGet_ScoreTable(False);

			// PlayerDistances.clear();
			// PlayerData.clear();
			PlayersReached.clear();
			foreach (Player in AllPlayers) {
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				declare Integer CP for Player;
				CP = 0;
				declare Integer CP as CPScore for Player.Score;
				CPScore = CP;
				declare Integer Round for Player;
				Round = 0;
				declare netwrite Integer Net_CP for UI;
				Net_CP = CP;
				declare netwrite Integer Net_Victory for UI;
				Net_Victory = 0;
				declare netwrite Integer Net_KnockOut for UI;
				Net_KnockOut = 0;
				declare netwrite Integer Net_StartTime for UI;
				Net_StartTime = StartTime+5000;
				declare netwrite Integer Net_Position for UI;
				Net_Position = 1;
				Player.Score.Clear();
				if (Players.exists(Player)) {
					Player.RaceStartTime = Now+3000;
					declare Integer LapStart for Player = 0;
					LapStart = Player.RaceStartTime;
					// SetDistance(0, Player.User.Login);
					// PlayerData[Player.User.Login] = Player.User.Name;
					Player.Score.Points = 0;
				}
			}
			foreach (Player in AllPlayers) {
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				
				UI.UILayers.clear();
				declare LayerGui <=> UIManager.UILayerCreate();
				LayerGui.Type = CUILayer::EUILayerType::Normal;
				UI.UILayers.add(LayerGui);
				LayerGui.ManialinkPage = MLGet_Gui(CtRankPanelType);
				
				// declare netwrite Integer[Text] Net_PlayerDistances for UI;
				// Net_PlayerDistances = PlayerDistances;
			}
			declare Integer TimeMarge = TimeMargeP1;
			declare Text Leader = "";
			declare Text LeaderNickName = "";
			EndLatestKO = "";
			EndWinner = "";
			while( True ) {
				yield;
				foreach (E in PendingEvents) {
					switch (E.Type) {
						case CTmModeEvent::EType::GiveUp:
							Discard(E);
						case CTmModeEvent::EType::WayPoint: {
							if (E.Player.RaceStartTime == 0 || E.RaceTime == 0) {
								log("Unknown driver "^E.Player.User.Login);
								Discard(E);
								continue;
							}
							declare UI <=> UIManager.GetUI(E.Player);
							if (UI == Null) continue;
							declare netwrite Integer[Integer] Net_ReachTimes for UI;
							declare Integer CP for E.Player;
							if (Net_ReachTimes.existskey(CP+1)) {
								if (Net_ReachTimes[CP+1]-E.Player.RaceStartTime-E.RaceTime <= 0) {
									// is out anyway
									ThrowMsg(UI, "$z$2c2$sYou're eliminated! ($f00+"^GetTime2(-1*(Net_ReachTimes[CP+1]-E.Player.RaceStartTime-E.RaceTime))^"$2c2)", True);
									Discard(E);
									continue;
								} else {
									declare netwrite Integer Net_AfterCPTimeLeft for UI;
									//Net_AfterCPTimeLeft = Net_ReachTimes[CP+1]-Now;
									Net_AfterCPTimeLeft = Net_ReachTimes[CP+1]-E.Player.RaceStartTime-E.RaceTime;
								}
							}
							declare Integer LapStart for E.Player = 0;
							CP += 1;
							declare Integer CP as CPScore for E.Player.Score;
							CPScore = CP;
							if (!PlayersReached.existskey(CP)) {
								declare Text[] stuff;
								PlayersReached[CP] = stuff;
							}
							PlayersReached[CP].add(E.Player.User.Name);
							// declare Integer OvertakeCount = 0;
							// declare Text Overtaken = "";
							// Figure out who this player has passed by
							// if (PlayersReached.existskey(CP-1)) { // if that cp doesnt exist, dont do it (happens at CP1)
								// if (PlayersReached[CP-1].exists(E.Player.User.Name)) { // just an error check
									// declare Integer prevpos = PlayersReached[CP-1].keyof(E.Player.User.Name);
									// for (i, 0, prevpos) {
										// if (!PlayersReached[CP].exists(PlayersReached[CP-1][i])) {
											// OvertakeCount += 1;
											// Overtaken = PlayersReached[CP-1][i];
											// ThrowMsg(UI, "$z$2c2$sYou have overtaken "^PlayersReached[CP-1][i], False);
											// foreach (OPlayer in AllPlayers) {
												// if (OPlayer.User.Name == PlayersReached[CP-1][i]) {
													// declare UII <=> UIManager.GetUI(OPlayer);
													// if (UII == Null) break;
													// ThrowMsg(UII, "$z$2c2$sYou've been overtaken by "^E.Player.User.Name, False);
													// break;
												// }
											// }
										// }
									// }
								// }
							// }
							// if (OvertakeCount == 1)
								// ThrowMsg(UI, "$z$2c2$sYou have overtaken "^Overtaken, False);
							// if (OvertakeCount > 1)
								// ThrowMsg(UI, "$z$2c2$sYou have overtaken "^OvertakeCount^" people", False);
							// ec //

							declare netwrite Integer Net_Position for UI;
							Net_Position = PlayersReached[CP].count;
							
							// XmlRpc.SendCallback("Endurance.Checkpoint", """{"Login":"{{{E.Player.User.Login}}}", "Checkpoint": {{{CP}}}, "Position": {{{Net_Position}}}, "Time": {{{E.RaceTime}}}, "EndLap": {{{GetLegitBoolText(E.IsEndLap)}}}, "EndRace": {{{GetLegitBoolText(E.IsEndRace)}}}, "CheckpointInLap": {{{E.CheckpointInLap}}}, "LapTime": {{{E.LapTime}}} }""");
							declare netwrite Integer Net_CP for UI;
							Net_CP = CP;
							// if (E.Player.Score.Points < CP)
							if (PlayersReached[CP].count > 1000)
								E.Player.Score.Points = CP*1000;
							else
								E.Player.Score.Points = CP*1000 + (1000-PlayersReached[CP].count);
							// SetDistance(CP*20, E.Player.User.Login);
							
							// If leader, set a new global goal //
							if (CP > ReachCP) {
								ReachCP = CP;
								ReachTimes[CP] = Now+TimeMarge;
								TimeMarge = MathLib::NearestInteger((TimeMarge*1.)*decreaser);
								if (Leader != E.Player.User.Login) {
									Leader = E.Player.User.Login;
									LeaderNickName = E.Player.User.Name;
									ThrowMsgAll(E.Player.User.Name^"$z$2c2$s takes the lead!", True);
									// XmlRpc.SendCallback("Endurance.NewLeader", """{"Login":"{{{E.Player.User.Login}}}"}""");
								}
							}
						
							
							PassOn(E);
							
							if (E.Player.Score.BestLap != Null && E.Player.Score.BestLap.Time > 3000) {
								declare netwrite Integer Net_TimeDiff for UI;
								declare netwrite Integer Net_TimeDiffCT for UI;
								Net_TimeDiff = -1*(E.Player.Score.BestLap.Checkpoints[E.Player.CurLap.Checkpoints.count-1]-(E.LapTime));
								Net_TimeDiffCT = Now;
							}
							
							if (E.IsEndLap) {
								if (E.Player.Score.BestLap.Time > E.Player.CurLap.Time || E.Player.Score.BestLap.Time == -1) {
									E.Player.Score.BestLap = E.Player.CurLap;
								}
							}
						} default:
							PassOn(E);
					}
				}
				foreach (E in XmlRpc.PendingEvents) {
					if (E.Type != CXmlRpcEvent::EType::Callback)
						continue;
					switch (E.Param1) {
						case "Endurance.CtSet.WarmingUp": {
							CtWarmingUp = E.Param2;
						}
						case "Endurance.CtSet.RankPanelType": {
							CtRankPanelType = TextLib::ToInteger(E.Param2);
							if (CtRankPanelType < 0 || CtRankPanelType > 1)
								CtRankPanelType = 0;
						}
						case "Endurance.CtSet.HideWarmingUpStatus": {
							CtHideWarmingUpStatus = (E.Param2 == "True" || E.Param2 == "true" || E.Param2 == "1");
						}
						case "Endurance.CtSet.PermitStarting": {
							CtPermitStarting = (E.Param2 == "True" || E.Param2 == "true" || E.Param2 == "1");
						}
						case "Endurance.ThrowMessageAll": {
							ThrowMsgAll(E.Param2, False);
						}
					}
				}
				if (MatchEndRequested) {
					Synchro();
					break;
				}

				declare Text[] Racers;
				foreach (Player in PlayersRacing)
					Racers.add(Player.User.Login);
				foreach (Player in AllPlayers) {
					declare UI <=> UIManager.GetUI(Player);
					if (UI == Null) continue;
					if (UI.UILayers.count != 1) { // add local GUI layer if not there
						UI.UILayers.clear();
						declare LayerGui <=> UIManager.UILayerCreate();
						LayerGui.Type = CUILayer::EUILayerType::Normal;
						UI.UILayers.add(LayerGui);
						LayerGui.ManialinkPage = MLGet_Gui(CtRankPanelType);
					}
					UI.ForceSpectator = Player.RaceStartTime == 0;
					declare netwrite Text[] Net_Racers for UI;
					Net_Racers = Racers;
					declare netwrite Text Net_Leader for UI;
					Net_Leader = Leader;
					declare netwrite Text Net_LeaderNickName for UI;
					Net_LeaderNickName = LeaderNickName;
					declare netwrite Integer Net_ReachCP for UI;
					declare netwrite Integer[Integer] Net_ReachTimes for UI;
					declare netwrite Integer Net_DriversLeft for UI;
					declare netwrite Integer Net_DriversTotal for UI;
					Net_ReachCP = ReachCP;
					Net_ReachTimes = ReachTimes;
					Net_DriversLeft = Racers.count;
					Net_DriversTotal = Players.count;
				}
				foreach (Player in PlayersRacing) {
					declare UI <=> UIManager.GetUI(Player);
					if (UI == Null) continue;
					declare netwrite Integer[Integer] Net_ReachTimes for UI;
					declare Integer CP for Player;
					if (Net_ReachTimes.existskey(CP+1) && Player.RaceStartTime != 0)
						if (Net_ReachTimes[CP+1]-Now <= 0) {
							// Player.Score.Points = Now - Player.RaceStartTime - LagMargin;
							// XmlRpc.SendCallback("Endurance.Kickout", """{"Login":"{{{Player.User.Login}}}", "Time": {{{Now-Player.RaceStartTime - LagMargin}}} }""");
							// log("Kickout: "^Player.User.Login^" - "^Player.RaceStartTime);
							if (PlayersRacing.count == 2) {
								EndLatestKO = Player.User.Login;
								Scores_Sort(CTmMode::ETmScoreSortOrder::TotalPoints);
								// UI.UISequence = CUIConfig::EUISequence::Podium;
							}
							Player.RaceStartTime = 0;
							ThrowMsgAll(Player.User.Name^"$z$2c2$s got eliminated!", False);
							declare netwrite Text Net_SpecSuggest for UI;
							Net_SpecSuggest = Leader;
							declare netwrite Integer Net_SpecSuggestTime for UI;
							Net_SpecSuggestTime = Now;
							foreach (Playerr in Players) {
								declare UIi <=> UIManager.GetUI(Player);
								if (UIi == Null) continue;
								declare netread Text Net_SpecTargetReq for UIi;
								if (Net_SpecTargetReq == Player.User.Login) {
									declare netwrite Text Net_SpecSuggest as Net_SpecSuggest2 for UIi;
									Net_SpecSuggest2 = Leader;
									declare netwrite Integer Net_SpecSuggestTime as Net_SpecSuggestTime2 for UIi;
									Net_SpecSuggestTime2 = Now;
								}
							}
							declare netwrite Integer Net_KnockOut for UI;
							Net_KnockOut = Now;
						}
				}
				if (((PlayersRacing.count == 2 && EndLatestKO != "") || PlayersRacing.count == 1) && EndOnVictory == 1) {
					if (PlayersRacing.existskey(0))
						PlayersRacing[0].RaceStartTime = 0;
					if (PlayersRacing.existskey(1))
						PlayersRacing[1].RaceStartTime = 0;
					
					declare Player <=> PlayersRacing[0];
					// best code ever :p
					if (Player.User.Login == EndLatestKO && PlayersRacing.count == 2) Player <=> PlayersRacing[1];
					if (Player != Null) {
						declare UI <=> UIManager.GetUI(Player);
						if (UI != Null) {
							Scores_Sort(CTmMode::ETmScoreSortOrder::TotalPoints);
							EndWinner = Player.User.Login;
							ThrowMsgAll(Player.User.Name^"$z$2c2$s wins this round!", True);
							winner = True;
							// XmlRpc.SendCallback("Endurance.Winner", """{"Login":"{{{Player.User.Login}}}"}""");
							Synchro();
							break;
						}
					}
				} else if (PlayersRacing.count == 0) { // if somehow all players quit not triggering the MatchEnd
					Synchro();
					break;
				}
				
				if (LastUIUpdateTime + C_UITickPeriod < Now) {
					Scores_Sort(CTmMode::ETmScoreSortOrder::TotalPoints);
					LastUIUpdateTime = Now;
					
					declare UsedLayers = Ident[];
					foreach (Player in AllPlayers) {
						if (!Players.exists(Player))
							Player.Score.Points = 0;
						declare UI <=> UIManager.GetUI(Player);
						if (UI == Null) continue;
						// declare netwrite Integer[Text] Net_PlayerDistances for UI;
						// Net_PlayerDistances = PlayerDistances;
						declare netwrite Integer Net_StartTime for UI;
						Net_StartTime = StartTime+5000;
								
						declare CUILayer LayerLocal;
						if (UI.UILayers.count != 1) {
							UI.UILayers.clear();
							LayerLocal <=> UIManager.UILayerCreate();
							LayerLocal.Type = CUILayer::EUILayerType::Normal;
							UI.UILayers.add(LayerLocal);
						} else {
							LayerLocal <=> UI.UILayers[0];
						}
						UsedLayers.add(LayerLocal.Id);

						if (Player.RaceStartTime == 0) {
							declare netread Net_SpecTargetReq for UI = "";
							if (Net_SpecTargetReq == "") {
								declare netwrite Text Net_SpecSuggest as Net_SpecSuggest2 for UI;
								Net_SpecSuggest2 = Leader;
								declare netwrite Integer Net_SpecSuggestTime as Net_SpecSuggestTime2 for UI;
								Net_SpecSuggestTime2 = Now;
								continue;
							}
							foreach (Racer in PlayersRacing) {
								if (Racer.User.Login == Net_SpecTargetReq) {
									declare UI2 <=> UIManager.GetUI(Racer);
									if (UI2 == Null) continue;
									declare netwrite Integer Net_CP as Net_CP1 for UI;
									declare netwrite Integer Net_CP as Net_CP2 for UI2;
									Net_CP1 = Net_CP2;
									declare netwrite Integer Net_Position as Net_Position1 for UI;
									declare netwrite Integer Net_Position as Net_Position2 for UI2;
									Net_Position1 = Net_Position2;
									declare netwrite Integer Net_AfterCPTimeLeft as Net_AfterCPTimeLeft1 for UI;
									declare netwrite Integer Net_AfterCPTimeLeft as Net_AfterCPTimeLeft2 for UI2;
									Net_AfterCPTimeLeft1 = Net_AfterCPTimeLeft2;
								}
							}
						}
					}
					declare LayersToRemove = Ident[];
					foreach (Layer in UIManager.UIAll.UILayers) { UsedLayers.add(Layer.Id); }
					UsedLayers.add(LayerScoresTable.Id);
					foreach (Layer in UIManager.UILayers) {
						if (!UsedLayers.exists(Layer.Id)) {
							LayersToRemove.add(Layer.Id);
						}
					}
					foreach (LayerId in LayersToRemove) {
						UIManager.UILayerDestroy(UIManager.UILayers[LayerId]);
					}
				}
			}
			UIManager.UIAll.StatusMessage = "";
			LayerScoresTable.ManialinkPage = MLGet_ScoreTable(False);
			foreach (Player in AllPlayers) {
				declare UI <=> UIManager.GetUI(Player);
				if (UI == Null) continue;
				if (UI.UILayers.count == 1) {
					declare CUILayer LayerLocal;
					LayerLocal <=> UI.UILayers[0];
					LayerLocal.ManialinkPage = "";
				}
			}
			UIManager.UIAll.CountdownEndTime = 0;
			StartTime = -1;
			EndTime = -1;
			Scores_Sort(CTmMode::ETmScoreSortOrder::TotalPoints);

			// XmlRpc.SendCallback("Endurance.RoundEnded", """{}""");
		}
		// declare Text Output = "{";
		// foreach (Score in Scores) {
			// if (Score.Points != 0) {
				// if (Output != "{") 
					// Output ^= ",";
				// if (Score.Points == StillRacingScore)
					// Output ^= "\""^Score.User.Login^"\":-1";
				// else
					// Output ^= "\""^Score.User.Login^"\":"^StillRacingScore+Score.Points;
			// }
		// }
		// XmlRpc.SendCallback("Endurance.MatchEnded", "{\"MatchTime\":"^Now-MatchStartTime^",\"Scores\":"^Output^"}}");
		foreach (Player in AllPlayers)
			Player.RaceStartTime = 0;
		UIManager.UIAll.BigMessage = "";
		UIManager.UIAll.StatusMessage = "";
		if (winner) {
			declare Text Output = "";
			foreach (Score in Scores) {
				if (Score.Points != 0) {
					Output ^= Score.User.Login^":"^Score.Points^",";
				}
			}
			enduro_scores = Output;
			XmlRpc.SendCallback_EndRound();

			UIManager.UIAll.ScoreTableOnlyManialink = True;
			UIManager.UIAll.OverlayHideRoundScores = True;
			UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
			Ladder_ComputeRank(CTmMode::ETmScoreSortOrder::TotalPoints);
			Ladder_CloseMatchRequest();
			LayerScoresTable.ManialinkPage = MLGet_ScoreTable(True);
			if (last_round == False) {
				UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
				declare Integer RoundEndWaitTime = Now+RoundEndWait-UnfollowSpawnSyncTime;
				WaitPass(RoundEndWaitTime);
				continue; // Start new round
			} else {
				CutOffTimeLimit = Now+MatchEndWait;
				UIManager.UIAll.CountdownEndTime = CutOffTimeLimit;
				UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
				WaitPass(CutOffTimeLimit);
			}
		}
		
		UIManager.UIAll.UILayers.clear();	
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;	
		UIManager.UIAll.StatusMessage = "Please wait...";
		foreach (Player in AllPlayers) {
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			UI.UISequence = CUIConfig::EUISequence::None;	
		}
		
		Synchro();
		
		RequestUnloadMap();
		wait(!MapLoaded);
	}
	UIManager.UILayerDestroy(LayerScoresTable);
}